/* tslint:disable */
/* eslint-disable */
/**
 * Early Access
 * API Reference â€” v2
 *
 * The version of the OpenAPI document: 2.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base'

/**
 * @type AddOrDeleteRulesRequest
 * @export
 */
export type AddOrDeleteRulesRequest = AddRulesRequest | DeleteRulesRequest

/**
 * @type AddOrDeleteRulesResponse
 * @export
 */
export type AddOrDeleteRulesResponse = AddRulesResponse | DeleteRulesResponse

/**
 *
 * @export
 * @interface AddRulesRequest
 */
export interface AddRulesRequest {
  /**
   *
   * @type {Array<RuleNoId>}
   * @memberof AddRulesRequest
   */
  add: Array<RuleNoId>
}
/**
 *
 * @export
 * @interface AddRulesResponse
 */
export interface AddRulesResponse {
  /**
   *
   * @type {Array<Rule>}
   * @memberof AddRulesResponse
   */
  data: Array<Rule>
  /**
   *
   * @type {RulesResponseMetadata}
   * @memberof AddRulesResponse
   */
  meta: RulesResponseMetadata
}
/**
 *
 * @export
 * @interface AnimatedGif
 */
export interface AnimatedGif {
  /**
   * The Media Key identifier for this attachment.
   * @type {string}
   * @memberof AnimatedGif
   */
  media_key?: string
  /**
   * The height of the media in pixels
   * @type {number}
   * @memberof AnimatedGif
   */
  height?: number
  /**
   * The width of the media in pixels
   * @type {number}
   * @memberof AnimatedGif
   */
  width?: number
  /**
   *
   * @type {string}
   * @memberof AnimatedGif
   */
  type?: AnimatedGifTypeEnum
  /**
   *
   * @type {string}
   * @memberof AnimatedGif
   */
  preview_image_url?: string
}

/**
 * @export
 * @enum {string}
 */
export enum AnimatedGifTypeEnum {
  AnimatedGif = 'animated_gif',
}

/**
 *
 * @export
 * @interface AnimatedGifAllOf
 */
export interface AnimatedGifAllOf {
  /**
   *
   * @type {string}
   * @memberof AnimatedGifAllOf
   */
  type?: AnimatedGifAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof AnimatedGifAllOf
   */
  preview_image_url?: string
}

/**
 * @export
 * @enum {string}
 */
export enum AnimatedGifAllOfTypeEnum {
  AnimatedGif = 'animated_gif',
}

/**
 *
 * @export
 * @interface CashtagEntity
 */
export interface CashtagEntity {
  /**
   * Index (zero-based) at which position this entity starts.
   * @type {number}
   * @memberof CashtagEntity
   */
  start: number
  /**
   * Index (zero-based) at which position this entity ends.
   * @type {number}
   * @memberof CashtagEntity
   */
  end: number
  /**
   *
   * @type {string}
   * @memberof CashtagEntity
   */
  tag: string
}
/**
 * Represent the portion of text recognized as a Cashtag, and its start and end position within the text.
 * @export
 * @interface CashtagFields
 */
export interface CashtagFields {
  /**
   *
   * @type {string}
   * @memberof CashtagFields
   */
  tag: string
}
/**
 * Your client has gone away.
 * @export
 * @interface ClientDisconnectedProblem
 */
export interface ClientDisconnectedProblem {
  /**
   *
   * @type {string}
   * @memberof ClientDisconnectedProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ClientDisconnectedProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof ClientDisconnectedProblem
   */
  type?: ClientDisconnectedProblemTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ClientDisconnectedProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsClientDisconnected = 'https://api.twitter.com/2/problems/client-disconnected',
}

/**
 *
 * @export
 * @interface ClientDisconnectedProblemAllOf
 */
export interface ClientDisconnectedProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof ClientDisconnectedProblemAllOf
   */
  type?: ClientDisconnectedProblemAllOfTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ClientDisconnectedProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsClientDisconnected = 'https://api.twitter.com/2/problems/client-disconnected',
}

/**
 * A problem that indicates your client is forbidden from making this request.
 * @export
 * @interface ClientForbiddenProblem
 */
export interface ClientForbiddenProblem {
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblem
   */
  type?: ClientForbiddenProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblem
   */
  reason?: ClientForbiddenProblemReasonEnum
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblem
   */
  registration_url?: string
}

/**
 * @export
 * @enum {string}
 */
export enum ClientForbiddenProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsClientForbidden = 'https://api.twitter.com/2/problems/client-forbidden',
}
/**
 * @export
 * @enum {string}
 */
export enum ClientForbiddenProblemReasonEnum {
  OfficialClientForbidden = 'official-client-forbidden',
  ClientNotEnrolled = 'client-not-enrolled',
}

/**
 *
 * @export
 * @interface ClientForbiddenProblemAllOf
 */
export interface ClientForbiddenProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblemAllOf
   */
  type?: ClientForbiddenProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblemAllOf
   */
  reason?: ClientForbiddenProblemAllOfReasonEnum
  /**
   *
   * @type {string}
   * @memberof ClientForbiddenProblemAllOf
   */
  registration_url?: string
}

/**
 * @export
 * @enum {string}
 */
export enum ClientForbiddenProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsClientForbidden = 'https://api.twitter.com/2/problems/client-forbidden',
}
/**
 * @export
 * @enum {string}
 */
export enum ClientForbiddenProblemAllOfReasonEnum {
  OfficialClientForbidden = 'official-client-forbidden',
  ClientNotEnrolled = 'client-not-enrolled',
}

/**
 *
 * @export
 * @interface CommonMediaFields
 */
export interface CommonMediaFields {
  /**
   * The Media Key identifier for this attachment.
   * @type {string}
   * @memberof CommonMediaFields
   */
  media_key?: string
  /**
   * The height of the media in pixels
   * @type {number}
   * @memberof CommonMediaFields
   */
  height?: number
  /**
   * The width of the media in pixels
   * @type {number}
   * @memberof CommonMediaFields
   */
  width?: number
}
/**
 * A problem that indicates something is wrong with the connection
 * @export
 * @interface ConnectionExceptionProblem
 */
export interface ConnectionExceptionProblem {
  /**
   *
   * @type {string}
   * @memberof ConnectionExceptionProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ConnectionExceptionProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof ConnectionExceptionProblem
   */
  type?: ConnectionExceptionProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof ConnectionExceptionProblem
   */
  connection_issue?: ConnectionExceptionProblemConnectionIssueEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ConnectionExceptionProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsStreamingConnection = 'https://api.twitter.com/2/problems/streaming-connection',
}
/**
 * @export
 * @enum {string}
 */
export enum ConnectionExceptionProblemConnectionIssueEnum {
  TooManyConnections = 'TooManyConnections',
  ProvisioningSubscription = 'ProvisioningSubscription',
}

/**
 *
 * @export
 * @interface ConnectionExceptionProblemAllOf
 */
export interface ConnectionExceptionProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof ConnectionExceptionProblemAllOf
   */
  type?: ConnectionExceptionProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof ConnectionExceptionProblemAllOf
   */
  connection_issue?: ConnectionExceptionProblemAllOfConnectionIssueEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ConnectionExceptionProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsStreamingConnection = 'https://api.twitter.com/2/problems/streaming-connection',
}
/**
 * @export
 * @enum {string}
 */
export enum ConnectionExceptionProblemAllOfConnectionIssueEnum {
  TooManyConnections = 'TooManyConnections',
  ProvisioningSubscription = 'ProvisioningSubscription',
}

/**
 * Annotation inferred from the tweet text.
 * @export
 * @interface ContextAnnotation
 */
export interface ContextAnnotation {
  /**
   *
   * @type {ContextAnnotationDomainFields}
   * @memberof ContextAnnotation
   */
  domain: ContextAnnotationDomainFields
  /**
   *
   * @type {ContextAnnotationEntityFields}
   * @memberof ContextAnnotation
   */
  entity: ContextAnnotationEntityFields
}
/**
 * Represents the data for the context annotation domain.
 * @export
 * @interface ContextAnnotationDomainFields
 */
export interface ContextAnnotationDomainFields {
  /**
   * The unique id for a context annotation domain.
   * @type {string}
   * @memberof ContextAnnotationDomainFields
   */
  id: string
  /**
   * Name of the context annotation domain.
   * @type {string}
   * @memberof ContextAnnotationDomainFields
   */
  name?: string
  /**
   * Description of the context annotation domain.
   * @type {string}
   * @memberof ContextAnnotationDomainFields
   */
  description?: string
}
/**
 * Represents the data for the context annotation entity.
 * @export
 * @interface ContextAnnotationEntityFields
 */
export interface ContextAnnotationEntityFields {
  /**
   * The unique id for a context annotation entity.
   * @type {string}
   * @memberof ContextAnnotationEntityFields
   */
  id: string
  /**
   * Name of the context annotation entity.
   * @type {string}
   * @memberof ContextAnnotationEntityFields
   */
  name?: string
  /**
   * Description of the context annotation entity.
   * @type {string}
   * @memberof ContextAnnotationEntityFields
   */
  description?: string
}
/**
 *
 * @export
 * @interface DeleteRulesRequest
 */
export interface DeleteRulesRequest {
  /**
   *
   * @type {Array<string>}
   * @memberof DeleteRulesRequest
   */
  ids?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof DeleteRulesRequest
   */
  values?: Array<string>
}
/**
 *
 * @export
 * @interface DeleteRulesResponse
 */
export interface DeleteRulesResponse {
  /**
   *
   * @type {RulesResponseMetadata}
   * @memberof DeleteRulesResponse
   */
  meta: RulesResponseMetadata
}
/**
 * A problem that indicates that the resource requested violates the precepts of this API.
 * @export
 * @interface DisallowedResourceProblem
 */
export interface DisallowedResourceProblem {
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblem
   */
  type?: DisallowedResourceProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblem
   */
  resource_id: string
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblem
   */
  resource_type: DisallowedResourceProblemResourceTypeEnum
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblem
   */
  section: DisallowedResourceProblemSectionEnum
}

/**
 * @export
 * @enum {string}
 */
export enum DisallowedResourceProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsDisallowedResource = 'https://api.twitter.com/2/problems/disallowed-resource',
}
/**
 * @export
 * @enum {string}
 */
export enum DisallowedResourceProblemResourceTypeEnum {
  Tweet = 'tweet',
  Media = 'media',
}
/**
 * @export
 * @enum {string}
 */
export enum DisallowedResourceProblemSectionEnum {
  Data = 'data',
  Includes = 'includes',
}

/**
 *
 * @export
 * @interface DisallowedResourceProblemAllOf
 */
export interface DisallowedResourceProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblemAllOf
   */
  type?: DisallowedResourceProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblemAllOf
   */
  resource_id: string
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblemAllOf
   */
  resource_type: DisallowedResourceProblemAllOfResourceTypeEnum
  /**
   *
   * @type {string}
   * @memberof DisallowedResourceProblemAllOf
   */
  section: DisallowedResourceProblemAllOfSectionEnum
}

/**
 * @export
 * @enum {string}
 */
export enum DisallowedResourceProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsDisallowedResource = 'https://api.twitter.com/2/problems/disallowed-resource',
}
/**
 * @export
 * @enum {string}
 */
export enum DisallowedResourceProblemAllOfResourceTypeEnum {
  Tweet = 'tweet',
  Media = 'media',
}
/**
 * @export
 * @enum {string}
 */
export enum DisallowedResourceProblemAllOfSectionEnum {
  Data = 'data',
  Includes = 'includes',
}

/**
 * The rule you have submitted is a duplicate.
 * @export
 * @interface DuplicateRuleProblem
 */
export interface DuplicateRuleProblem {
  /**
   *
   * @type {string}
   * @memberof DuplicateRuleProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof DuplicateRuleProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof DuplicateRuleProblem
   */
  type?: DuplicateRuleProblemTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum DuplicateRuleProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsDuplicateRules = 'https://api.twitter.com/2/problems/duplicate-rules',
}

/**
 *
 * @export
 * @interface DuplicateRuleProblemAllOf
 */
export interface DuplicateRuleProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof DuplicateRuleProblemAllOf
   */
  type?: DuplicateRuleProblemAllOfTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum DuplicateRuleProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsDuplicateRules = 'https://api.twitter.com/2/problems/duplicate-rules',
}

/**
 * Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.
 * @export
 * @interface EntityIndices
 */
export interface EntityIndices {
  /**
   * Index (zero-based) at which position this entity starts.
   * @type {number}
   * @memberof EntityIndices
   */
  start: number
  /**
   * Index (zero-based) at which position this entity ends.
   * @type {number}
   * @memberof EntityIndices
   */
  end: number
}
/**
 *
 * @export
 * @interface Expansions
 */
export interface Expansions {
  /**
   *
   * @type {Array<User>}
   * @memberof Expansions
   */
  users?: Array<User>
  /**
   *
   * @type {Array<Tweet>}
   * @memberof Expansions
   */
  tweets?: Array<Tweet>
  /**
   *
   * @type {Array<Place>}
   * @memberof Expansions
   */
  places?: Array<Place>
  /**
   *
   * @type {Array<Media>}
   * @memberof Expansions
   */
  media?: Array<Media>
  /**
   *
   * @type {Array<Poll>}
   * @memberof Expansions
   */
  polls?: Array<Poll>
}
/**
 * A problem that indicates that you are not allowed to see a particular field on a Tweet, User, etc.
 * @export
 * @interface FieldUnauthorizedProblem
 */
export interface FieldUnauthorizedProblem {
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblem
   */
  type?: FieldUnauthorizedProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblem
   */
  section: FieldUnauthorizedProblemSectionEnum
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblem
   */
  resource_type: FieldUnauthorizedProblemResourceTypeEnum
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblem
   */
  field: string
}

/**
 * @export
 * @enum {string}
 */
export enum FieldUnauthorizedProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsNotAuthorizedForField = 'https://api.twitter.com/2/problems/not-authorized-for-field',
}
/**
 * @export
 * @enum {string}
 */
export enum FieldUnauthorizedProblemSectionEnum {
  Data = 'data',
  Includes = 'includes',
}
/**
 * @export
 * @enum {string}
 */
export enum FieldUnauthorizedProblemResourceTypeEnum {
  Tweet = 'tweet',
  Media = 'media',
}

/**
 *
 * @export
 * @interface FieldUnauthorizedProblemAllOf
 */
export interface FieldUnauthorizedProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblemAllOf
   */
  type?: FieldUnauthorizedProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblemAllOf
   */
  section: FieldUnauthorizedProblemAllOfSectionEnum
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblemAllOf
   */
  resource_type: FieldUnauthorizedProblemAllOfResourceTypeEnum
  /**
   *
   * @type {string}
   * @memberof FieldUnauthorizedProblemAllOf
   */
  field: string
}

/**
 * @export
 * @enum {string}
 */
export enum FieldUnauthorizedProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsNotAuthorizedForField = 'https://api.twitter.com/2/problems/not-authorized-for-field',
}
/**
 * @export
 * @enum {string}
 */
export enum FieldUnauthorizedProblemAllOfSectionEnum {
  Data = 'data',
  Includes = 'includes',
}
/**
 * @export
 * @enum {string}
 */
export enum FieldUnauthorizedProblemAllOfResourceTypeEnum {
  Tweet = 'tweet',
  Media = 'media',
}

/**
 * @type FilteredStreamingTweet
 * A tweet or error that can be returned by the streaming tweet API
 * @export
 */
export type FilteredStreamingTweet =
  | FilteredStreamingTweetOneOf
  | StreamingTweetOneOf

/**
 * The values returned with a successful streamed tweet. Includes the user provided rules that the tweet matched.
 * @export
 * @interface FilteredStreamingTweetOneOf
 */
export interface FilteredStreamingTweetOneOf {
  /**
   *
   * @type {Tweet}
   * @memberof FilteredStreamingTweetOneOf
   */
  data: Tweet
  /**
   * The list of rules which matched the tweet
   * @type {Array<FilteredStreamingTweetOneOfMatchingRules>}
   * @memberof FilteredStreamingTweetOneOf
   */
  matching_rules: Array<FilteredStreamingTweetOneOfMatchingRules>
  /**
   *
   * @type {Expansions}
   * @memberof FilteredStreamingTweetOneOf
   */
  includes?: Expansions
}
/**
 *
 * @export
 * @interface FilteredStreamingTweetOneOfMatchingRules
 */
export interface FilteredStreamingTweetOneOfMatchingRules {
  /**
   * Unique identifier of this rule.
   * @type {string}
   * @memberof FilteredStreamingTweetOneOfMatchingRules
   */
  id: string
  /**
   * The user-supplied tag assigned to the rule which matched
   * @type {string}
   * @memberof FilteredStreamingTweetOneOfMatchingRules
   */
  tag?: string
}
/**
 *
 * @export
 * @interface FullTextEntities
 */
export interface FullTextEntities {
  /**
   *
   * @type {Array<UrlEntity>}
   * @memberof FullTextEntities
   */
  urls?: Array<UrlEntity>
  /**
   *
   * @type {Array<HashtagEntity>}
   * @memberof FullTextEntities
   */
  hashtags?: Array<HashtagEntity>
  /**
   *
   * @type {Array<MentionEntity>}
   * @memberof FullTextEntities
   */
  mentions?: Array<MentionEntity>
  /**
   *
   * @type {Array<CashtagEntity>}
   * @memberof FullTextEntities
   */
  cashtags?: Array<CashtagEntity>
}
/**
 * A generic problem with no additional information beyond that provided by the HTTP status code.
 * @export
 * @interface GenericProblem
 */
export interface GenericProblem {
  /**
   *
   * @type {string}
   * @memberof GenericProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof GenericProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof GenericProblem
   */
  type?: GenericProblemTypeEnum
  /**
   *
   * @type {number}
   * @memberof GenericProblem
   */
  status: number
}

/**
 * @export
 * @enum {string}
 */
export enum GenericProblemTypeEnum {
  Aboutblank = 'about:blank',
}

/**
 *
 * @export
 * @interface GenericProblemAllOf
 */
export interface GenericProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof GenericProblemAllOf
   */
  type?: GenericProblemAllOfTypeEnum
  /**
   *
   * @type {number}
   * @memberof GenericProblemAllOf
   */
  status: number
}

/**
 * @export
 * @enum {string}
 */
export enum GenericProblemAllOfTypeEnum {
  Aboutblank = 'about:blank',
}

/**
 *
 * @export
 * @interface Geo
 */
export interface Geo {
  /**
   *
   * @type {string}
   * @memberof Geo
   */
  type: GeoTypeEnum
  /**
   *
   * @type {Array<number>}
   * @memberof Geo
   */
  bbox: Array<number>
  /**
   *
   * @type {Point}
   * @memberof Geo
   */
  geometry?: Point
  /**
   *
   * @type {object}
   * @memberof Geo
   */
  properties: object
}

/**
 * @export
 * @enum {string}
 */
export enum GeoTypeEnum {
  Feature = 'Feature',
}

/**
 *
 * @export
 * @interface HashtagEntity
 */
export interface HashtagEntity {
  /**
   * Index (zero-based) at which position this entity starts.
   * @type {number}
   * @memberof HashtagEntity
   */
  start: number
  /**
   * Index (zero-based) at which position this entity ends.
   * @type {number}
   * @memberof HashtagEntity
   */
  end: number
  /**
   * The text of the Hashtag
   * @type {string}
   * @memberof HashtagEntity
   */
  tag: string
}
/**
 * Represent the portion of text recognized as a Hashtag, and its start and end position within the text.
 * @export
 * @interface HashtagFields
 */
export interface HashtagFields {
  /**
   * The text of the Hashtag
   * @type {string}
   * @memberof HashtagFields
   */
  tag: string
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   *
   * @type {boolean}
   * @memberof InlineObject
   */
  hidden?: boolean
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {InlineObject}
   * @memberof InlineResponse200
   */
  data?: InlineObject
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {Array<Tweet>}
   * @memberof InlineResponse2001
   */
  data?: Array<Tweet>
  /**
   *
   * @type {Expansions}
   * @memberof InlineResponse2001
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof InlineResponse2001
   */
  errors?: Array<Problem>
  /**
   *
   * @type {InlineResponse2001Meta}
   * @memberof InlineResponse2001
   */
  meta?: InlineResponse2001Meta
}
/**
 *
 * @export
 * @interface InlineResponse2001Meta
 */
export interface InlineResponse2001Meta {
  /**
   * Most recent Tweet Id returned by search query
   * @type {string}
   * @memberof InlineResponse2001Meta
   */
  newest_id?: string
  /**
   * Oldest Tweet Id returned by search query
   * @type {string}
   * @memberof InlineResponse2001Meta
   */
  oldest_id?: string
  /**
   * This value is used to get the next \'page\' of results by providing it to the next_token parameter.
   * @type {string}
   * @memberof InlineResponse2001Meta
   */
  next_token?: string
  /**
   * Number of search query results
   * @type {number}
   * @memberof InlineResponse2001Meta
   */
  result_count?: number
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   *
   * @type {Array<Rule>}
   * @memberof InlineResponse2002
   */
  data: Array<Rule>
  /**
   *
   * @type {RulesResponseMetadata}
   * @memberof InlineResponse2002
   */
  meta: RulesResponseMetadata
}
/**
 * A problem that indicates this request is invalid.
 * @export
 * @interface InvalidRequestProblem
 */
export interface InvalidRequestProblem {
  /**
   *
   * @type {string}
   * @memberof InvalidRequestProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof InvalidRequestProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof InvalidRequestProblem
   */
  type?: InvalidRequestProblemTypeEnum
  /**
   *
   * @type {Array<InvalidRequestProblemAllOfErrors>}
   * @memberof InvalidRequestProblem
   */
  errors?: Array<InvalidRequestProblemAllOfErrors>
}

/**
 * @export
 * @enum {string}
 */
export enum InvalidRequestProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsInvalidRequest = 'https://api.twitter.com/2/problems/invalid-request',
}

/**
 *
 * @export
 * @interface InvalidRequestProblemAllOf
 */
export interface InvalidRequestProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof InvalidRequestProblemAllOf
   */
  type?: InvalidRequestProblemAllOfTypeEnum
  /**
   *
   * @type {Array<InvalidRequestProblemAllOfErrors>}
   * @memberof InvalidRequestProblemAllOf
   */
  errors?: Array<InvalidRequestProblemAllOfErrors>
}

/**
 * @export
 * @enum {string}
 */
export enum InvalidRequestProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsInvalidRequest = 'https://api.twitter.com/2/problems/invalid-request',
}

/**
 *
 * @export
 * @interface InvalidRequestProblemAllOfErrors
 */
export interface InvalidRequestProblemAllOfErrors {
  /**
   *
   * @type {{ [key: string]: Array<string>; }}
   * @memberof InvalidRequestProblemAllOfErrors
   */
  parameters?: { [key: string]: Array<string> }
  /**
   *
   * @type {string}
   * @memberof InvalidRequestProblemAllOfErrors
   */
  message?: string
}
/**
 * The rule you have submitted is invalid.
 * @export
 * @interface InvalidRuleProblem
 */
export interface InvalidRuleProblem {
  /**
   *
   * @type {string}
   * @memberof InvalidRuleProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof InvalidRuleProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof InvalidRuleProblem
   */
  type?: InvalidRuleProblemTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum InvalidRuleProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsInvalidRules = 'https://api.twitter.com/2/problems/invalid-rules',
}

/**
 *
 * @export
 * @interface InvalidRuleProblemAllOf
 */
export interface InvalidRuleProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof InvalidRuleProblemAllOf
   */
  type?: InvalidRuleProblemAllOfTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum InvalidRuleProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsInvalidRules = 'https://api.twitter.com/2/problems/invalid-rules',
}

/**
 * @type Media
 * @export
 */
export type Media = AnimatedGif | Photo | Video

/**
 *
 * @export
 * @interface MentionEntity
 */
export interface MentionEntity {
  /**
   * Index (zero-based) at which position this entity starts.
   * @type {number}
   * @memberof MentionEntity
   */
  start: number
  /**
   * Index (zero-based) at which position this entity ends.
   * @type {number}
   * @memberof MentionEntity
   */
  end: number
  /**
   * The Twitter handle (screen name) of this user.
   * @type {string}
   * @memberof MentionEntity
   */
  username: string
}
/**
 * Represent the portion of text recognized as a User mention, and its start and end position within the text.
 * @export
 * @interface MentionFields
 */
export interface MentionFields {
  /**
   * The Twitter handle (screen name) of this user.
   * @type {string}
   * @memberof MentionFields
   */
  username: string
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {number}
   * @memberof ModelError
   */
  code: number
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  message: string
}
/**
 * You have been disconnected for operational reasons.
 * @export
 * @interface OperationalDisconnectProblem
 */
export interface OperationalDisconnectProblem {
  /**
   *
   * @type {string}
   * @memberof OperationalDisconnectProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof OperationalDisconnectProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof OperationalDisconnectProblem
   */
  type?: OperationalDisconnectProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof OperationalDisconnectProblem
   */
  disconnect_type?: OperationalDisconnectProblemDisconnectTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum OperationalDisconnectProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsOperationalDisconnect = 'https://api.twitter.com/2/problems/operational-disconnect',
}
/**
 * @export
 * @enum {string}
 */
export enum OperationalDisconnectProblemDisconnectTypeEnum {
  OperationalDisconnect = 'OperationalDisconnect',
  UpstreamOperationalDisconnect = 'UpstreamOperationalDisconnect',
  ForceDisconnect = 'ForceDisconnect',
  UpstreamUncleanDisconnect = 'UpstreamUncleanDisconnect',
  SlowReader = 'SlowReader',
  InternalError = 'InternalError',
  PackageUpgraded = 'PackageUpgraded',
  PackageDowngraded = 'PackageDowngraded',
  ClientApplicationStateDegraded = 'ClientApplicationStateDegraded',
}

/**
 *
 * @export
 * @interface OperationalDisconnectProblemAllOf
 */
export interface OperationalDisconnectProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof OperationalDisconnectProblemAllOf
   */
  type?: OperationalDisconnectProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof OperationalDisconnectProblemAllOf
   */
  disconnect_type?: OperationalDisconnectProblemAllOfDisconnectTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum OperationalDisconnectProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsOperationalDisconnect = 'https://api.twitter.com/2/problems/operational-disconnect',
}
/**
 * @export
 * @enum {string}
 */
export enum OperationalDisconnectProblemAllOfDisconnectTypeEnum {
  OperationalDisconnect = 'OperationalDisconnect',
  UpstreamOperationalDisconnect = 'UpstreamOperationalDisconnect',
  ForceDisconnect = 'ForceDisconnect',
  UpstreamUncleanDisconnect = 'UpstreamUncleanDisconnect',
  SlowReader = 'SlowReader',
  InternalError = 'InternalError',
  PackageUpgraded = 'PackageUpgraded',
  PackageDowngraded = 'PackageDowngraded',
  ClientApplicationStateDegraded = 'ClientApplicationStateDegraded',
}

/**
 *
 * @export
 * @interface Photo
 */
export interface Photo {
  /**
   * The Media Key identifier for this attachment.
   * @type {string}
   * @memberof Photo
   */
  media_key?: string
  /**
   * The height of the media in pixels
   * @type {number}
   * @memberof Photo
   */
  height?: number
  /**
   * The width of the media in pixels
   * @type {number}
   * @memberof Photo
   */
  width?: number
  /**
   *
   * @type {string}
   * @memberof Photo
   */
  type?: PhotoTypeEnum
  /**
   *
   * @type {string}
   * @memberof Photo
   */
  url?: string
}

/**
 * @export
 * @enum {string}
 */
export enum PhotoTypeEnum {
  Photo = 'photo',
}

/**
 *
 * @export
 * @interface PhotoAllOf
 */
export interface PhotoAllOf {
  /**
   *
   * @type {string}
   * @memberof PhotoAllOf
   */
  type?: PhotoAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof PhotoAllOf
   */
  url?: string
}

/**
 * @export
 * @enum {string}
 */
export enum PhotoAllOfTypeEnum {
  Photo = 'photo',
}

/**
 *
 * @export
 * @interface Place
 */
export interface Place {
  /**
   * The identifier for this place
   * @type {string}
   * @memberof Place
   */
  id: string
  /**
   * The human readable name of this place.
   * @type {string}
   * @memberof Place
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof Place
   */
  country_code?: string
  /**
   *
   * @type {PlaceType}
   * @memberof Place
   */
  place_type?: PlaceType
  /**
   *
   * @type {string}
   * @memberof Place
   */
  full_name: string
  /**
   *
   * @type {string}
   * @memberof Place
   */
  country?: string
  /**
   *
   * @type {Array<string>}
   * @memberof Place
   */
  contained_within?: Array<string>
  /**
   *
   * @type {Geo}
   * @memberof Place
   */
  geo?: Geo
}
/**
 *
 * @export
 * @enum {string}
 */
export enum PlaceType {
  Poi = 'poi',
  Neighborhood = 'neighborhood',
  City = 'city',
  Admin = 'admin',
  Country = 'country',
  Unknown = 'unknown',
}

/**
 * A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object.
 * @export
 * @interface Point
 */
export interface Point {
  /**
   *
   * @type {string}
   * @memberof Point
   */
  type: PointTypeEnum
  /**
   * A [GeoJson Position](https://tools.ietf.org/html/rfc7946#section-3.1.1) in the format `[longitude,latitude]`.
   * @type {Array<number>}
   * @memberof Point
   */
  coordinates: Array<number>
}

/**
 * @export
 * @enum {string}
 */
export enum PointTypeEnum {
  Point = 'Point',
}

/**
 * Represent a Poll attached to a Tweet
 * @export
 * @interface Poll
 */
export interface Poll {
  /**
   * Unique identifier of this poll.
   * @type {string}
   * @memberof Poll
   */
  id: string
  /**
   *
   * @type {Array<PollOption>}
   * @memberof Poll
   */
  options: Array<PollOption>
  /**
   *
   * @type {string}
   * @memberof Poll
   */
  voting_status?: PollVotingStatusEnum
  /**
   *
   * @type {string}
   * @memberof Poll
   */
  end_datetime?: string
  /**
   *
   * @type {number}
   * @memberof Poll
   */
  duration_minutes?: number
}

/**
 * @export
 * @enum {string}
 */
export enum PollVotingStatusEnum {
  Open = 'open',
  Closed = 'closed',
}

/**
 * Describes a choice in a Poll object.
 * @export
 * @interface PollOption
 */
export interface PollOption {
  /**
   * Position of this choice in the poll.
   * @type {number}
   * @memberof PollOption
   */
  position: number
  /**
   * The text of a poll choice.
   * @type {string}
   * @memberof PollOption
   */
  label: string
  /**
   * Number of users who voted for this choice.
   * @type {number}
   * @memberof PollOption
   */
  votes: number
}
/**
 * @type Problem
 * An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
 * @export
 */
export type Problem =
  | ClientDisconnectedProblem
  | ClientForbiddenProblem
  | ConnectionExceptionProblem
  | DisallowedResourceProblem
  | DuplicateRuleProblem
  | FieldUnauthorizedProblem
  | GenericProblem
  | InvalidRequestProblem
  | InvalidRuleProblem
  | OperationalDisconnectProblem
  | ResourceNotFoundProblem
  | ResourceUnauthorizedProblem
  | RulesCapProblem
  | UnsupportedAuthenticationProblem
  | UsageCapExceededProblem

/**
 *
 * @export
 * @interface ProblemFields
 */
export interface ProblemFields {
  /**
   *
   * @type {string}
   * @memberof ProblemFields
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ProblemFields
   */
  detail: string
}
/**
 * Shows who can reply a Tweet. Fields returned are everyone, mentioned_users, and following.
 * @export
 * @enum {string}
 */
export enum ReplySettings {
  Everyone = 'everyone',
  MentionedUsers = 'mentionedUsers',
  Following = 'following',
  Other = 'other',
}

/**
 * A problem that indicates that a given Tweet, User, etc. does not exist.
 * @export
 * @interface ResourceNotFoundProblem
 */
export interface ResourceNotFoundProblem {
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblem
   */
  type?: ResourceNotFoundProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblem
   */
  parameter: string
  /**
   * Value will match the schema of the field.
   * @type {any}
   * @memberof ResourceNotFoundProblem
   */
  value: any | null
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblem
   */
  resource_type: ResourceNotFoundProblemResourceTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ResourceNotFoundProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsResourceNotFound = 'https://api.twitter.com/2/problems/resource-not-found',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceNotFoundProblemResourceTypeEnum {
  User = 'user',
  Tweet = 'tweet',
  Media = 'media',
}

/**
 *
 * @export
 * @interface ResourceNotFoundProblemAllOf
 */
export interface ResourceNotFoundProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblemAllOf
   */
  type?: ResourceNotFoundProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblemAllOf
   */
  parameter: string
  /**
   * Value will match the schema of the field.
   * @type {any}
   * @memberof ResourceNotFoundProblemAllOf
   */
  value: any | null
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundProblemAllOf
   */
  resource_type: ResourceNotFoundProblemAllOfResourceTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ResourceNotFoundProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsResourceNotFound = 'https://api.twitter.com/2/problems/resource-not-found',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceNotFoundProblemAllOfResourceTypeEnum {
  User = 'user',
  Tweet = 'tweet',
  Media = 'media',
}

/**
 * A problem that indicates you are not allowed to see a particular Tweet, User, etc.
 * @export
 * @interface ResourceUnauthorizedProblem
 */
export interface ResourceUnauthorizedProblem {
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  type?: ResourceUnauthorizedProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  value: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  parameter: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  section: ResourceUnauthorizedProblemSectionEnum
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblem
   */
  resource_type: ResourceUnauthorizedProblemResourceTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ResourceUnauthorizedProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsNotAuthorizedForResource = 'https://api.twitter.com/2/problems/not-authorized-for-resource',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceUnauthorizedProblemSectionEnum {
  Data = 'data',
  Includes = 'includes',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceUnauthorizedProblemResourceTypeEnum {
  Tweet = 'tweet',
  User = 'user',
  Media = 'media',
}

/**
 *
 * @export
 * @interface ResourceUnauthorizedProblemAllOf
 */
export interface ResourceUnauthorizedProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblemAllOf
   */
  type?: ResourceUnauthorizedProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblemAllOf
   */
  value: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblemAllOf
   */
  parameter: string
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblemAllOf
   */
  section: ResourceUnauthorizedProblemAllOfSectionEnum
  /**
   *
   * @type {string}
   * @memberof ResourceUnauthorizedProblemAllOf
   */
  resource_type: ResourceUnauthorizedProblemAllOfResourceTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum ResourceUnauthorizedProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsNotAuthorizedForResource = 'https://api.twitter.com/2/problems/not-authorized-for-resource',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceUnauthorizedProblemAllOfSectionEnum {
  Data = 'data',
  Includes = 'includes',
}
/**
 * @export
 * @enum {string}
 */
export enum ResourceUnauthorizedProblemAllOfResourceTypeEnum {
  Tweet = 'tweet',
  User = 'user',
  Media = 'media',
}

/**
 *
 * @export
 * @interface Rule
 */
export interface Rule {
  /**
   * The filterlang value of the rule.
   * @type {string}
   * @memberof Rule
   */
  value: string
  /**
   * A tag meant for the labeling of user provided rules.
   * @type {string}
   * @memberof Rule
   */
  tag?: string
  /**
   * Unique identifier of this rule.
   * @type {string}
   * @memberof Rule
   */
  id?: string
}
/**
 *
 * @export
 * @interface RuleNoId
 */
export interface RuleNoId {
  /**
   * The filterlang value of the rule.
   * @type {string}
   * @memberof RuleNoId
   */
  value: string
  /**
   * A tag meant for the labeling of user provided rules.
   * @type {string}
   * @memberof RuleNoId
   */
  tag?: string
}
/**
 * You have exceeded the maximum number of rules.
 * @export
 * @interface RulesCapProblem
 */
export interface RulesCapProblem {
  /**
   *
   * @type {string}
   * @memberof RulesCapProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof RulesCapProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof RulesCapProblem
   */
  type?: RulesCapProblemTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum RulesCapProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsRuleCap = 'https://api.twitter.com/2/problems/rule-cap',
}

/**
 *
 * @export
 * @interface RulesCapProblemAllOf
 */
export interface RulesCapProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof RulesCapProblemAllOf
   */
  type?: RulesCapProblemAllOfTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum RulesCapProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsRuleCap = 'https://api.twitter.com/2/problems/rule-cap',
}

/**
 * @type RulesRequestSummary
 * @export
 */
export type RulesRequestSummary =
  | RulesRequestSummaryOneOf
  | RulesRequestSummaryOneOf1

/**
 *
 * @export
 * @interface RulesRequestSummaryOneOf
 */
export interface RulesRequestSummaryOneOf {
  /**
   *
   * @type {number}
   * @memberof RulesRequestSummaryOneOf
   */
  created: number
  /**
   *
   * @type {number}
   * @memberof RulesRequestSummaryOneOf
   */
  not_created: number
}
/**
 *
 * @export
 * @interface RulesRequestSummaryOneOf1
 */
export interface RulesRequestSummaryOneOf1 {
  /**
   *
   * @type {number}
   * @memberof RulesRequestSummaryOneOf1
   */
  deleted: number
  /**
   *
   * @type {number}
   * @memberof RulesRequestSummaryOneOf1
   */
  not_deleted: number
}
/**
 *
 * @export
 * @interface RulesResponseMetadata
 */
export interface RulesResponseMetadata {
  /**
   *
   * @type {string}
   * @memberof RulesResponseMetadata
   */
  sent: string
  /**
   *
   * @type {RulesRequestSummary}
   * @memberof RulesResponseMetadata
   */
  summary?: RulesRequestSummary
}
/**
 *
 * @export
 * @interface SingleTweetLookupResponse
 */
export interface SingleTweetLookupResponse {
  /**
   *
   * @type {Tweet}
   * @memberof SingleTweetLookupResponse
   */
  data?: Tweet
  /**
   *
   * @type {Expansions}
   * @memberof SingleTweetLookupResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof SingleTweetLookupResponse
   */
  errors?: Array<Problem>
}
/**
 *
 * @export
 * @interface SingleUserLookupResponse
 */
export interface SingleUserLookupResponse {
  /**
   *
   * @type {User}
   * @memberof SingleUserLookupResponse
   */
  data?: User
  /**
   *
   * @type {Expansions}
   * @memberof SingleUserLookupResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof SingleUserLookupResponse
   */
  errors?: Array<Problem>
}
/**
 * @type StreamingTweet
 * A tweet or error that can be returned by the streaming tweet API.
 * @export
 */
export type StreamingTweet = SingleTweetLookupResponse | StreamingTweetOneOf

/**
 *
 * @export
 * @interface StreamingTweetOneOf
 */
export interface StreamingTweetOneOf {
  /**
   *
   * @type {Array<Problem>}
   * @memberof StreamingTweetOneOf
   */
  errors: Array<Problem>
}
/**
 *
 * @export
 * @interface Tweet
 */
export interface Tweet {
  /**
   * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof Tweet
   */
  id: string
  /**
   * Creation time of the Tweet.
   * @type {string}
   * @memberof Tweet
   */
  created_at?: string
  /**
   * The content of the Tweet.
   * @type {string}
   * @memberof Tweet
   */
  text: string
  /**
   * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof Tweet
   */
  author_id?: string
  /**
   * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof Tweet
   */
  in_reply_to_user_id?: string
  /**
   * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof Tweet
   */
  conversation_id?: string
  /**
   *
   * @type {ReplySettings}
   * @memberof Tweet
   */
  reply_settings?: ReplySettings
  /**
   * A list of Tweets this Tweet refers to. For example, if the parent Tweet is a Retweet, a Quoted Tweet or a Reply, it will include the related Tweet referenced to by its parent.
   * @type {Array<TweetReferencedTweets>}
   * @memberof Tweet
   */
  referenced_tweets?: Array<TweetReferencedTweets>
  /**
   *
   * @type {TweetAttachments}
   * @memberof Tweet
   */
  attachments?: TweetAttachments
  /**
   *
   * @type {Array<ContextAnnotation>}
   * @memberof Tweet
   */
  context_annotations?: Array<ContextAnnotation>
  /**
   *
   * @type {TweetWithheld}
   * @memberof Tweet
   */
  withheld?: TweetWithheld
  /**
   *
   * @type {TweetGeo}
   * @memberof Tweet
   */
  geo?: TweetGeo
  /**
   *
   * @type {FullTextEntities}
   * @memberof Tweet
   */
  entities?: FullTextEntities
  /**
   *
   * @type {TweetPublicMetrics}
   * @memberof Tweet
   */
  public_metrics?: TweetPublicMetrics
  /**
   * Indicates if this Tweet contains URLs marked as sensitive, for example content suitable for mature audiences.
   * @type {boolean}
   * @memberof Tweet
   */
  possibly_sensitive?: boolean
  /**
   * Language of the Tweet, if detected by Twitter. Returned as a BCP47 language tag.
   * @type {string}
   * @memberof Tweet
   */
  lang?: string
  /**
   * The name of the app the user Tweeted from.
   * @type {string}
   * @memberof Tweet
   */
  source?: string
  /**
   *
   * @type {TweetNonPublicMetrics}
   * @memberof Tweet
   */
  non_public_metrics?: TweetNonPublicMetrics
  /**
   *
   * @type {TweetPromotedMetrics}
   * @memberof Tweet
   */
  promoted_metrics?: TweetPromotedMetrics
  /**
   *
   * @type {TweetOrganicMetrics}
   * @memberof Tweet
   */
  organic_metrics?: TweetOrganicMetrics
}
/**
 * Specifies the type of attachments (if any) present in this Tweet.
 * @export
 * @interface TweetAttachments
 */
export interface TweetAttachments {
  /**
   * A list of Media Keys for each one of the media attachments (if media are attached).
   * @type {Array<string>}
   * @memberof TweetAttachments
   */
  media_keys?: Array<string>
  /**
   * A list of poll IDs (if polls are attached).
   * @type {Array<string>}
   * @memberof TweetAttachments
   */
  poll_ids?: Array<string>
}
/**
 * The location tagged on the Tweet, if the user provided one.
 * @export
 * @interface TweetGeo
 */
export interface TweetGeo {
  /**
   *
   * @type {Point}
   * @memberof TweetGeo
   */
  coordinates?: Point
  /**
   * The identifier for this place
   * @type {string}
   * @memberof TweetGeo
   */
  place_id?: string
}
/**
 *
 * @export
 * @interface TweetLookupResponse
 */
export interface TweetLookupResponse {
  /**
   *
   * @type {Array<Tweet>}
   * @memberof TweetLookupResponse
   */
  data?: Array<Tweet>
  /**
   *
   * @type {Expansions}
   * @memberof TweetLookupResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof TweetLookupResponse
   */
  errors?: Array<Problem>
  /**
   *
   * @type {TweetLookupResponseMeta}
   * @memberof TweetLookupResponse
   */
  meta?: TweetLookupResponseMeta
}
/**
 *
 * @export
 * @interface TweetLookupResponseMeta
 */
export interface TweetLookupResponseMeta {
  /**
   * The next cursor provided by the response.
   * @type {string}
   * @memberof TweetLookupResponseMeta
   */
  next_token?: string
  /**
   * The ID of the oldest Tweet in the response.
   * @type {string}
   * @memberof TweetLookupResponseMeta
   */
  oldest_id?: string
  /**
   * The ID of the newest Tweet in the response.
   * @type {string}
   * @memberof TweetLookupResponseMeta
   */
  newest_id?: string
  /**
   * The previous cursor provided by the response.
   * @type {string}
   * @memberof TweetLookupResponseMeta
   */
  previous_token?: string
  /**
   * Number of results returned in the response.
   * @type {number}
   * @memberof TweetLookupResponseMeta
   */
  result_count?: number
}
/**
 * Nonpublic engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetNonPublicMetrics
 */
export interface TweetNonPublicMetrics {
  /**
   * Number of times this Tweet has been viewed.
   * @type {number}
   * @memberof TweetNonPublicMetrics
   */
  impression_count?: number
}
/**
 * Organic nonpublic engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetOrganicMetrics
 */
export interface TweetOrganicMetrics {
  /**
   * Number of times this Tweet has been viewed.
   * @type {number}
   * @memberof TweetOrganicMetrics
   */
  impression_count: number
  /**
   * Number of times this Tweet has been Retweeted.
   * @type {number}
   * @memberof TweetOrganicMetrics
   */
  retweet_count: number
  /**
   * Number of times this Tweet has been replied to.
   * @type {number}
   * @memberof TweetOrganicMetrics
   */
  reply_count: number
  /**
   * Number of times this Tweet has been liked.
   * @type {number}
   * @memberof TweetOrganicMetrics
   */
  like_count: number
}
/**
 * Promoted nonpublic engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetPromotedMetrics
 */
export interface TweetPromotedMetrics {
  /**
   * Number of times this Tweet has been viewed.
   * @type {number}
   * @memberof TweetPromotedMetrics
   */
  impression_count?: number
  /**
   * Number of times this Tweet has been liked.
   * @type {number}
   * @memberof TweetPromotedMetrics
   */
  like_count?: number
  /**
   * Number of times this Tweet has been replied to.
   * @type {number}
   * @memberof TweetPromotedMetrics
   */
  reply_count?: number
  /**
   * Number of times this Tweet has been Retweeted.
   * @type {number}
   * @memberof TweetPromotedMetrics
   */
  retweet_count?: number
}
/**
 * Engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetPublicMetrics
 */
export interface TweetPublicMetrics {
  /**
   * Number of times this Tweet has been Retweeted.
   * @type {number}
   * @memberof TweetPublicMetrics
   */
  retweet_count: number
  /**
   * Number of times this Tweet has been replied to.
   * @type {number}
   * @memberof TweetPublicMetrics
   */
  reply_count: number
  /**
   * Number of times this Tweet has been liked.
   * @type {number}
   * @memberof TweetPublicMetrics
   */
  like_count: number
  /**
   * Number of times this Tweet has been quoted.
   * @type {number}
   * @memberof TweetPublicMetrics
   */
  quote_count?: number
}
/**
 *
 * @export
 * @interface TweetReferencedTweets
 */
export interface TweetReferencedTweets {
  /**
   *
   * @type {string}
   * @memberof TweetReferencedTweets
   */
  type: TweetReferencedTweetsTypeEnum
  /**
   * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof TweetReferencedTweets
   */
  id: string
}

/**
 * @export
 * @enum {string}
 */
export enum TweetReferencedTweetsTypeEnum {
  Retweeted = 'retweeted',
  Quoted = 'quoted',
  RepliedTo = 'replied_to',
}

/**
 *
 * @export
 * @interface TweetSearchResponse
 */
export interface TweetSearchResponse {
  /**
   *
   * @type {Array<Tweet>}
   * @memberof TweetSearchResponse
   */
  data?: Array<Tweet>
  /**
   *
   * @type {Expansions}
   * @memberof TweetSearchResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof TweetSearchResponse
   */
  errors?: Array<Problem>
  /**
   *
   * @type {InlineResponse2001Meta}
   * @memberof TweetSearchResponse
   */
  meta?: InlineResponse2001Meta
}
/**
 * Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
 * @export
 * @interface TweetWithheld
 */
export interface TweetWithheld {
  /**
   * Indicates if the content is being withheld for on the basis of copyright infringement.
   * @type {boolean}
   * @memberof TweetWithheld
   */
  copyright: boolean
  /**
   * Provides a list of countries where this content is not available.
   * @type {Array<string>}
   * @memberof TweetWithheld
   */
  country_codes: Array<string>
  /**
   * Indicates whether the content being withheld is the `tweet` or a `user`.
   * @type {string}
   * @memberof TweetWithheld
   */
  scope?: TweetWithheldScopeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum TweetWithheldScopeEnum {
  Tweet = 'tweet',
  User = 'user',
}

/**
 * Represent the portion of text recognized as a URL.
 * @export
 * @interface URLFields
 */
export interface URLFields {
  /**
   * A validly formatted URL.
   * @type {string}
   * @memberof URLFields
   */
  url: string
  /**
   * A validly formatted URL.
   * @type {string}
   * @memberof URLFields
   */
  expanded_url?: string
  /**
   * The URL as displayed in the Twitter client.
   * @type {string}
   * @memberof URLFields
   */
  display_url?: string
  /**
   * Fully resolved url
   * @type {string}
   * @memberof URLFields
   */
  unwound_url?: string
  /**
   * HTTP Status Code.
   * @type {number}
   * @memberof URLFields
   */
  status?: number
  /**
   * Title of the page the URL points to.
   * @type {string}
   * @memberof URLFields
   */
  title?: string
  /**
   * Description of the URL landing page.
   * @type {string}
   * @memberof URLFields
   */
  description?: string
  /**
   *
   * @type {Array<URLImage>}
   * @memberof URLFields
   */
  images?: Array<URLImage>
}
/**
 * Represent the information for the URL image
 * @export
 * @interface URLImage
 */
export interface URLImage {
  /**
   * A validly formatted URL.
   * @type {string}
   * @memberof URLImage
   */
  url?: string
  /**
   * The height of the media in pixels
   * @type {number}
   * @memberof URLImage
   */
  height?: number
  /**
   * The width of the media in pixels
   * @type {number}
   * @memberof URLImage
   */
  width?: number
}
/**
 * A problem that indicates that the authentication used is not supported.
 * @export
 * @interface UnsupportedAuthenticationProblem
 */
export interface UnsupportedAuthenticationProblem {
  /**
   *
   * @type {string}
   * @memberof UnsupportedAuthenticationProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof UnsupportedAuthenticationProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof UnsupportedAuthenticationProblem
   */
  type?: UnsupportedAuthenticationProblemTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum UnsupportedAuthenticationProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsUnsupportedAuthentication = 'https://api.twitter.com/2/problems/unsupported-authentication',
}

/**
 *
 * @export
 * @interface UnsupportedAuthenticationProblemAllOf
 */
export interface UnsupportedAuthenticationProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof UnsupportedAuthenticationProblemAllOf
   */
  type?: UnsupportedAuthenticationProblemAllOfTypeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum UnsupportedAuthenticationProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsUnsupportedAuthentication = 'https://api.twitter.com/2/problems/unsupported-authentication',
}

/**
 * Represent the portion of text recognized as a URL, and its start and end position within the text.
 * @export
 * @interface UrlEntity
 */
export interface UrlEntity {
  /**
   * Index (zero-based) at which position this entity starts.
   * @type {number}
   * @memberof UrlEntity
   */
  start: number
  /**
   * Index (zero-based) at which position this entity ends.
   * @type {number}
   * @memberof UrlEntity
   */
  end: number
  /**
   * A validly formatted URL.
   * @type {string}
   * @memberof UrlEntity
   */
  url: string
  /**
   * A validly formatted URL.
   * @type {string}
   * @memberof UrlEntity
   */
  expanded_url?: string
  /**
   * The URL as displayed in the Twitter client.
   * @type {string}
   * @memberof UrlEntity
   */
  display_url?: string
  /**
   * Fully resolved url
   * @type {string}
   * @memberof UrlEntity
   */
  unwound_url?: string
  /**
   * HTTP Status Code.
   * @type {number}
   * @memberof UrlEntity
   */
  status?: number
  /**
   * Title of the page the URL points to.
   * @type {string}
   * @memberof UrlEntity
   */
  title?: string
  /**
   * Description of the URL landing page.
   * @type {string}
   * @memberof UrlEntity
   */
  description?: string
  /**
   *
   * @type {Array<URLImage>}
   * @memberof UrlEntity
   */
  images?: Array<URLImage>
}
/**
 * A problem that indicates that a usage cap has been exceeded.
 * @export
 * @interface UsageCapExceededProblem
 */
export interface UsageCapExceededProblem {
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblem
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblem
   */
  detail: string
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblem
   */
  type?: UsageCapExceededProblemTypeEnum
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblem
   */
  period?: UsageCapExceededProblemPeriodEnum
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblem
   */
  scope?: UsageCapExceededProblemScopeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum UsageCapExceededProblemTypeEnum {
  HttpsApiTwitterCom2ProblemsUsageCapped = 'https://api.twitter.com/2/problems/usage-capped',
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCapExceededProblemPeriodEnum {
  Daily = 'Daily',
  Monthly = 'Monthly',
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCapExceededProblemScopeEnum {
  Account = 'Account',
  Product = 'Product',
}

/**
 *
 * @export
 * @interface UsageCapExceededProblemAllOf
 */
export interface UsageCapExceededProblemAllOf {
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblemAllOf
   */
  type?: UsageCapExceededProblemAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblemAllOf
   */
  period?: UsageCapExceededProblemAllOfPeriodEnum
  /**
   *
   * @type {string}
   * @memberof UsageCapExceededProblemAllOf
   */
  scope?: UsageCapExceededProblemAllOfScopeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum UsageCapExceededProblemAllOfTypeEnum {
  HttpsApiTwitterCom2ProblemsUsageCapped = 'https://api.twitter.com/2/problems/usage-capped',
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCapExceededProblemAllOfPeriodEnum {
  Daily = 'Daily',
  Monthly = 'Monthly',
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCapExceededProblemAllOfScopeEnum {
  Account = 'Account',
  Product = 'Product',
}

/**
 * The Twitter User object
 * @export
 * @interface User
 */
export interface User {
  /**
   * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof User
   */
  id: string
  /**
   * Creation time of this user.
   * @type {string}
   * @memberof User
   */
  created_at?: string
  /**
   * The friendly name of this user, as shown on their profile.
   * @type {string}
   * @memberof User
   */
  name: string
  /**
   * The Twitter handle (screen name) of this user.
   * @type {string}
   * @memberof User
   */
  username: string
  /**
   * Indicates if this user has chosen to protect their Tweets (in other words, if this user\'s Tweets are private).
   * @type {boolean}
   * @memberof User
   */
  _protected?: boolean
  /**
   * Indicate if this user is a verified Twitter User.
   * @type {boolean}
   * @memberof User
   */
  verified?: boolean
  /**
   *
   * @type {UserWithheld}
   * @memberof User
   */
  withheld?: UserWithheld
  /**
   * The URL to the profile image for this user.
   * @type {string}
   * @memberof User
   */
  profile_image_url?: string
  /**
   * The location specified in the user\'s profile, if the user provided one. As this is a freeform value, it may not indicate a valid location, but it may be fuzzily evaluated when performing searches with location queries.
   * @type {string}
   * @memberof User
   */
  location?: string
  /**
   * The URL specified in the user\'s profile.
   * @type {string}
   * @memberof User
   */
  url?: string
  /**
   * The text of this user\'s profile description (also known as bio), if the user provided one.
   * @type {string}
   * @memberof User
   */
  description?: string
  /**
   *
   * @type {UserEntities}
   * @memberof User
   */
  entities?: UserEntities
  /**
   * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
   * @type {string}
   * @memberof User
   */
  pinned_tweet_id?: string
  /**
   *
   * @type {UserPublicMetrics}
   * @memberof User
   */
  public_metrics?: UserPublicMetrics
}
/**
 * A list of metadata found in the user\'s profile description.
 * @export
 * @interface UserEntities
 */
export interface UserEntities {
  /**
   *
   * @type {UserEntitiesUrl}
   * @memberof UserEntities
   */
  url?: UserEntitiesUrl
  /**
   *
   * @type {FullTextEntities}
   * @memberof UserEntities
   */
  description?: FullTextEntities
}
/**
 * Expanded details for the URL specified in the user\'s profile, with start and end indices.
 * @export
 * @interface UserEntitiesUrl
 */
export interface UserEntitiesUrl {
  /**
   *
   * @type {Array<UrlEntity>}
   * @memberof UserEntitiesUrl
   */
  urls?: Array<UrlEntity>
}
/**
 *
 * @export
 * @interface UserLookupResponse
 */
export interface UserLookupResponse {
  /**
   *
   * @type {Array<User>}
   * @memberof UserLookupResponse
   */
  data?: Array<User>
  /**
   *
   * @type {Expansions}
   * @memberof UserLookupResponse
   */
  includes?: Expansions
  /**
   *
   * @type {Array<Problem>}
   * @memberof UserLookupResponse
   */
  errors?: Array<Problem>
}
/**
 * A list of metrics for this user
 * @export
 * @interface UserPublicMetrics
 */
export interface UserPublicMetrics {
  /**
   * Number of users who are following this user.
   * @type {number}
   * @memberof UserPublicMetrics
   */
  followers_count: number
  /**
   * Number of users this user is following.
   * @type {number}
   * @memberof UserPublicMetrics
   */
  following_count: number
  /**
   * The number of Tweets (including Retweets) posted by this user.
   * @type {number}
   * @memberof UserPublicMetrics
   */
  tweet_count: number
  /**
   * The number of lists that include this user.
   * @type {number}
   * @memberof UserPublicMetrics
   */
  listed_count: number
}
/**
 * Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
 * @export
 * @interface UserWithheld
 */
export interface UserWithheld {
  /**
   * Provides a list of countries where this content is not available.
   * @type {Array<string>}
   * @memberof UserWithheld
   */
  country_codes: Array<string>
  /**
   * Indicates that the content being withheld is a `user`.
   * @type {string}
   * @memberof UserWithheld
   */
  scope?: UserWithheldScopeEnum
}

/**
 * @export
 * @enum {string}
 */
export enum UserWithheldScopeEnum {
  User = 'user',
}

/**
 *
 * @export
 * @interface Video
 */
export interface Video {
  /**
   * The Media Key identifier for this attachment.
   * @type {string}
   * @memberof Video
   */
  media_key?: string
  /**
   * The height of the media in pixels
   * @type {number}
   * @memberof Video
   */
  height?: number
  /**
   * The width of the media in pixels
   * @type {number}
   * @memberof Video
   */
  width?: number
  /**
   *
   * @type {string}
   * @memberof Video
   */
  type?: VideoTypeEnum
  /**
   *
   * @type {string}
   * @memberof Video
   */
  preview_image_url?: string
  /**
   *
   * @type {number}
   * @memberof Video
   */
  duration_ms?: number
  /**
   *
   * @type {VideoAllOfPublicMetrics}
   * @memberof Video
   */
  public_metrics?: VideoAllOfPublicMetrics
  /**
   *
   * @type {VideoAllOfNonPublicMetrics}
   * @memberof Video
   */
  non_public_metrics?: VideoAllOfNonPublicMetrics
  /**
   *
   * @type {VideoAllOfOrganicMetrics}
   * @memberof Video
   */
  organic_metrics?: VideoAllOfOrganicMetrics
  /**
   *
   * @type {VideoAllOfPromotedMetrics}
   * @memberof Video
   */
  promoted_metrics?: VideoAllOfPromotedMetrics
}

/**
 * @export
 * @enum {string}
 */
export enum VideoTypeEnum {
  Video = 'video',
}

/**
 *
 * @export
 * @interface VideoAllOf
 */
export interface VideoAllOf {
  /**
   *
   * @type {string}
   * @memberof VideoAllOf
   */
  type?: VideoAllOfTypeEnum
  /**
   *
   * @type {string}
   * @memberof VideoAllOf
   */
  preview_image_url?: string
  /**
   *
   * @type {number}
   * @memberof VideoAllOf
   */
  duration_ms?: number
  /**
   *
   * @type {VideoAllOfPublicMetrics}
   * @memberof VideoAllOf
   */
  public_metrics?: VideoAllOfPublicMetrics
  /**
   *
   * @type {VideoAllOfNonPublicMetrics}
   * @memberof VideoAllOf
   */
  non_public_metrics?: VideoAllOfNonPublicMetrics
  /**
   *
   * @type {VideoAllOfOrganicMetrics}
   * @memberof VideoAllOf
   */
  organic_metrics?: VideoAllOfOrganicMetrics
  /**
   *
   * @type {VideoAllOfPromotedMetrics}
   * @memberof VideoAllOf
   */
  promoted_metrics?: VideoAllOfPromotedMetrics
}

/**
 * @export
 * @enum {string}
 */
export enum VideoAllOfTypeEnum {
  Video = 'video',
}

/**
 * Nonpublic engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfNonPublicMetrics
 */
export interface VideoAllOfNonPublicMetrics {
  /**
   * Number of users who made it through 0% of the video.
   * @type {number}
   * @memberof VideoAllOfNonPublicMetrics
   */
  playback_0_count?: number
  /**
   * Number of users who made it through 25% of the video.
   * @type {number}
   * @memberof VideoAllOfNonPublicMetrics
   */
  playback_25_count?: number
  /**
   * Number of users who made it through 50% of the video.
   * @type {number}
   * @memberof VideoAllOfNonPublicMetrics
   */
  playback_50_count?: number
  /**
   * Number of users who made it through 75% of the video.
   * @type {number}
   * @memberof VideoAllOfNonPublicMetrics
   */
  playback_75_count?: number
  /**
   * Number of users who made it through 100% of the video.
   * @type {number}
   * @memberof VideoAllOfNonPublicMetrics
   */
  playback_100_count?: number
}
/**
 * Organic nonpublic engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfOrganicMetrics
 */
export interface VideoAllOfOrganicMetrics {
  /**
   * Number of users who made it through 0% of the video.
   * @type {number}
   * @memberof VideoAllOfOrganicMetrics
   */
  playback_0_count?: number
  /**
   * Number of users who made it through 25% of the video.
   * @type {number}
   * @memberof VideoAllOfOrganicMetrics
   */
  playback_25_count?: number
  /**
   * Number of users who made it through 50% of the video.
   * @type {number}
   * @memberof VideoAllOfOrganicMetrics
   */
  playback_50_count?: number
  /**
   * Number of users who made it through 75% of the video.
   * @type {number}
   * @memberof VideoAllOfOrganicMetrics
   */
  playback_75_count?: number
  /**
   * Number of users who made it through 100% of the video.
   * @type {number}
   * @memberof VideoAllOfOrganicMetrics
   */
  playback_100_count?: number
  /**
   * Number of times this video has been viewed.
   * @type {number}
   * @memberof VideoAllOfOrganicMetrics
   */
  view_count?: number
}
/**
 * Promoted nonpublic engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfPromotedMetrics
 */
export interface VideoAllOfPromotedMetrics {
  /**
   * Number of users who made it through 0% of the video.
   * @type {number}
   * @memberof VideoAllOfPromotedMetrics
   */
  playback_0_count?: number
  /**
   * Number of users who made it through 25% of the video.
   * @type {number}
   * @memberof VideoAllOfPromotedMetrics
   */
  playback_25_count?: number
  /**
   * Number of users who made it through 50% of the video.
   * @type {number}
   * @memberof VideoAllOfPromotedMetrics
   */
  playback_50_count?: number
  /**
   * Number of users who made it through 75% of the video.
   * @type {number}
   * @memberof VideoAllOfPromotedMetrics
   */
  playback_75_count?: number
  /**
   * Number of users who made it through 100% of the video.
   * @type {number}
   * @memberof VideoAllOfPromotedMetrics
   */
  playback_100_count?: number
  /**
   * Number of times this video has been viewed.
   * @type {number}
   * @memberof VideoAllOfPromotedMetrics
   */
  view_count?: number
}
/**
 * Engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfPublicMetrics
 */
export interface VideoAllOfPublicMetrics {
  /**
   * Number of times this video has been viewed.
   * @type {number}
   * @memberof VideoAllOfPublicMetrics
   */
  view_count?: number
}

/**
 * GeneralApi - axios parameter creator
 * @export
 */
export const GeneralApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
     * @summary Returns the open api spec document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpenApiSpec: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/2/openapi.json`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * GeneralApi - functional programming interface
 * @export
 */
export const GeneralApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
     * @summary Returns the open api spec document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOpenApiSpec(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await GeneralApiAxiosParamCreator(
        configuration,
      ).getOpenApiSpec(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * GeneralApi - factory interface
 * @export
 */
export const GeneralApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
     * @summary Returns the open api spec document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpenApiSpec(options?: any): AxiosPromise<object> {
      return GeneralApiFp(configuration)
        .getOpenApiSpec(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * GeneralApi - object-oriented interface
 * @export
 * @class GeneralApi
 * @extends {BaseAPI}
 */
export class GeneralApi extends BaseAPI {
  /**
   * Full open api spec in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
   * @summary Returns the open api spec document.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GeneralApi
   */
  public getOpenApiSpec(options?: any) {
    return GeneralApiFp(this.configuration)
      .getOpenApiSpec(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * @summary Add or delete rules from a user\'s active rule set.
     * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest
     * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOrDeleteRules: async (
      addOrDeleteRulesRequest: AddOrDeleteRulesRequest,
      dryRun?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addOrDeleteRulesRequest' is not null or undefined
      if (
        addOrDeleteRulesRequest === null ||
        addOrDeleteRulesRequest === undefined
      ) {
        throw new RequiredError(
          'addOrDeleteRulesRequest',
          'Required parameter addOrDeleteRulesRequest was null or undefined when calling addOrDeleteRules.',
        )
      }
      const localVarPath = `/2/tweets/search/stream/rules`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (dryRun !== undefined) {
        localVarQueryParameter['dry_run'] = dryRun
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const nonString = typeof addOrDeleteRulesRequest !== 'string'
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type'],
            )
          : nonString
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            addOrDeleteRulesRequest !== undefined
              ? addOrDeleteRulesRequest
              : {},
          )
        : addOrDeleteRulesRequest || ''

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * @summary Returns rules from a user\'s active rule set.
     * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRules: async (
      ids?: Array<string>,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/2/tweets/search/stream/rules`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (ids) {
        localVarQueryParameter['ids'] = ids
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * @summary Add or delete rules from a user\'s active rule set.
     * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest
     * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addOrDeleteRules(
      addOrDeleteRulesRequest: AddOrDeleteRulesRequest,
      dryRun?: boolean,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AddOrDeleteRulesResponse>
    > {
      const localVarAxiosArgs = await RulesApiAxiosParamCreator(
        configuration,
      ).addOrDeleteRules(addOrDeleteRulesRequest, dryRun, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * @summary Returns rules from a user\'s active rule set.
     * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRules(
      ids?: Array<string>,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2002>
    > {
      const localVarAxiosArgs = await RulesApiAxiosParamCreator(
        configuration,
      ).getRules(ids, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * @summary Add or delete rules from a user\'s active rule set.
     * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest
     * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOrDeleteRules(
      addOrDeleteRulesRequest: AddOrDeleteRulesRequest,
      dryRun?: boolean,
      options?: any,
    ): AxiosPromise<AddOrDeleteRulesResponse> {
      return RulesApiFp(configuration)
        .addOrDeleteRules(addOrDeleteRulesRequest, dryRun, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * @summary Returns rules from a user\'s active rule set.
     * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRules(
      ids?: Array<string>,
      options?: any,
    ): AxiosPromise<InlineResponse2002> {
      return RulesApiFp(configuration)
        .getRules(ids, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for addOrDeleteRules operation in RulesApi.
 * @export
 * @interface RulesApiAddOrDeleteRulesRequest
 */
export interface RulesApiAddOrDeleteRulesRequest {
  /**
   *
   * @type {AddOrDeleteRulesRequest}
   * @memberof RulesApiAddOrDeleteRules
   */
  readonly addOrDeleteRulesRequest: AddOrDeleteRulesRequest

  /**
   * Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
   * @type {boolean}
   * @memberof RulesApiAddOrDeleteRules
   */
  readonly dryRun?: boolean
}

/**
 * Request parameters for getRules operation in RulesApi.
 * @export
 * @interface RulesApiGetRulesRequest
 */
export interface RulesApiGetRulesRequest {
  /**
   * A comma-separated list of Rule IDs.
   * @type {Array<string>}
   * @memberof RulesApiGetRules
   */
  readonly ids?: Array<string>
}

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
  /**
   * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
   * @summary Add or delete rules from a user\'s active rule set.
   * @param {RulesApiAddOrDeleteRulesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RulesApi
   */
  public addOrDeleteRules(
    requestParameters: RulesApiAddOrDeleteRulesRequest,
    options?: any,
  ) {
    return RulesApiFp(this.configuration)
      .addOrDeleteRules(
        requestParameters.addOrDeleteRulesRequest,
        requestParameters.dryRun,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
   * @summary Returns rules from a user\'s active rule set.
   * @param {RulesApiGetRulesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RulesApi
   */
  public getRules(
    requestParameters: RulesApiGetRulesRequest = {},
    options?: any,
  ) {
    return RulesApiFp(this.configuration)
      .getRules(requestParameters.ids, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Returns Tweets that match a search query.
     * @summary Returns Tweets that match a search query.
     * @param {string} query One query/rule/filter for matching Tweets. Up to 1024 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsFullarchiveSearch: async (
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      if (query === null || query === undefined) {
        throw new RequiredError(
          'query',
          'Required parameter query was null or undefined when calling tweetsFullarchiveSearch.',
        )
      }
      const localVarPath = `/2/tweets/search/all`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] =
          (startTime as any) instanceof Date
            ? (startTime as any).toISOString()
            : startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] =
          (endTime as any) instanceof Date
            ? (endTime as any).toISOString()
            : endTime
      }

      if (sinceId !== undefined) {
        localVarQueryParameter['since_id'] = sinceId
      }

      if (untilId !== undefined) {
        localVarQueryParameter['until_id'] = untilId
      }

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (nextToken !== undefined) {
        localVarQueryParameter['next_token'] = nextToken
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns Tweets from the last 7 days that match a search query.
     * @summary Returns Tweets from the last 7 days that match a search query.
     * @param {string} query One query/rule/filter for matching Tweets. Up to 512 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsRecentSearch: async (
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      if (query === null || query === undefined) {
        throw new RequiredError(
          'query',
          'Required parameter query was null or undefined when calling tweetsRecentSearch.',
        )
      }
      const localVarPath = `/2/tweets/search/recent`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] =
          (startTime as any) instanceof Date
            ? (startTime as any).toISOString()
            : startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] =
          (endTime as any) instanceof Date
            ? (endTime as any).toISOString()
            : endTime
      }

      if (sinceId !== undefined) {
        localVarQueryParameter['since_id'] = sinceId
      }

      if (untilId !== undefined) {
        localVarQueryParameter['until_id'] = untilId
      }

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (nextToken !== undefined) {
        localVarQueryParameter['next_token'] = nextToken
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns Tweets that match a search query.
     * @summary Returns Tweets that match a search query.
     * @param {string} query One query/rule/filter for matching Tweets. Up to 1024 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tweetsFullarchiveSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2001>
    > {
      const localVarAxiosArgs = await SearchApiAxiosParamCreator(
        configuration,
      ).tweetsFullarchiveSearch(
        query,
        startTime,
        endTime,
        sinceId,
        untilId,
        maxResults,
        nextToken,
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns Tweets from the last 7 days that match a search query.
     * @summary Returns Tweets from the last 7 days that match a search query.
     * @param {string} query One query/rule/filter for matching Tweets. Up to 512 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tweetsRecentSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TweetSearchResponse>
    > {
      const localVarAxiosArgs = await SearchApiAxiosParamCreator(
        configuration,
      ).tweetsRecentSearch(
        query,
        startTime,
        endTime,
        sinceId,
        untilId,
        maxResults,
        nextToken,
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Returns Tweets that match a search query.
     * @summary Returns Tweets that match a search query.
     * @param {string} query One query/rule/filter for matching Tweets. Up to 1024 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsFullarchiveSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<InlineResponse2001> {
      return SearchApiFp(configuration)
        .tweetsFullarchiveSearch(
          query,
          startTime,
          endTime,
          sinceId,
          untilId,
          maxResults,
          nextToken,
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns Tweets from the last 7 days that match a search query.
     * @summary Returns Tweets from the last 7 days that match a search query.
     * @param {string} query One query/rule/filter for matching Tweets. Up to 512 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsRecentSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<TweetSearchResponse> {
      return SearchApiFp(configuration)
        .tweetsRecentSearch(
          query,
          startTime,
          endTime,
          sinceId,
          untilId,
          maxResults,
          nextToken,
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for tweetsFullarchiveSearch operation in SearchApi.
 * @export
 * @interface SearchApiTweetsFullarchiveSearchRequest
 */
export interface SearchApiTweetsFullarchiveSearchRequest {
  /**
   * One query/rule/filter for matching Tweets. Up to 1024 characters.
   * @type {string}
   * @memberof SearchApiTweetsFullarchiveSearch
   */
  readonly query: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
   * @type {string}
   * @memberof SearchApiTweetsFullarchiveSearch
   */
  readonly startTime?: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
   * @type {string}
   * @memberof SearchApiTweetsFullarchiveSearch
   */
  readonly endTime?: string

  /**
   * Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
   * @type {string}
   * @memberof SearchApiTweetsFullarchiveSearch
   */
  readonly sinceId?: string

  /**
   * Returns results with a Tweet ID less than (that is, older than) the specified ID.
   * @type {string}
   * @memberof SearchApiTweetsFullarchiveSearch
   */
  readonly untilId?: string

  /**
   * The maximum number of search results to be returned by a request.
   * @type {number}
   * @memberof SearchApiTweetsFullarchiveSearch
   */
  readonly maxResults?: number

  /**
   * This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
   * @type {string}
   * @memberof SearchApiTweetsFullarchiveSearch
   */
  readonly nextToken?: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof SearchApiTweetsFullarchiveSearch
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof SearchApiTweetsFullarchiveSearch
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof SearchApiTweetsFullarchiveSearch
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>}
   * @memberof SearchApiTweetsFullarchiveSearch
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof SearchApiTweetsFullarchiveSearch
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof SearchApiTweetsFullarchiveSearch
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * Request parameters for tweetsRecentSearch operation in SearchApi.
 * @export
 * @interface SearchApiTweetsRecentSearchRequest
 */
export interface SearchApiTweetsRecentSearchRequest {
  /**
   * One query/rule/filter for matching Tweets. Up to 512 characters.
   * @type {string}
   * @memberof SearchApiTweetsRecentSearch
   */
  readonly query: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
   * @type {string}
   * @memberof SearchApiTweetsRecentSearch
   */
  readonly startTime?: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
   * @type {string}
   * @memberof SearchApiTweetsRecentSearch
   */
  readonly endTime?: string

  /**
   * Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
   * @type {string}
   * @memberof SearchApiTweetsRecentSearch
   */
  readonly sinceId?: string

  /**
   * Returns results with a Tweet ID less than (that is, older than) the specified ID.
   * @type {string}
   * @memberof SearchApiTweetsRecentSearch
   */
  readonly untilId?: string

  /**
   * The maximum number of search results to be returned by a request.
   * @type {number}
   * @memberof SearchApiTweetsRecentSearch
   */
  readonly maxResults?: number

  /**
   * This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
   * @type {string}
   * @memberof SearchApiTweetsRecentSearch
   */
  readonly nextToken?: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof SearchApiTweetsRecentSearch
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof SearchApiTweetsRecentSearch
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof SearchApiTweetsRecentSearch
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>}
   * @memberof SearchApiTweetsRecentSearch
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof SearchApiTweetsRecentSearch
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof SearchApiTweetsRecentSearch
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
  /**
   * Returns Tweets that match a search query.
   * @summary Returns Tweets that match a search query.
   * @param {SearchApiTweetsFullarchiveSearchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchApi
   */
  public tweetsFullarchiveSearch(
    requestParameters: SearchApiTweetsFullarchiveSearchRequest,
    options?: any,
  ) {
    return SearchApiFp(this.configuration)
      .tweetsFullarchiveSearch(
        requestParameters.query,
        requestParameters.startTime,
        requestParameters.endTime,
        requestParameters.sinceId,
        requestParameters.untilId,
        requestParameters.maxResults,
        requestParameters.nextToken,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns Tweets from the last 7 days that match a search query.
   * @summary Returns Tweets from the last 7 days that match a search query.
   * @param {SearchApiTweetsRecentSearchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchApi
   */
  public tweetsRecentSearch(
    requestParameters: SearchApiTweetsRecentSearchRequest,
    options?: any,
  ) {
    return SearchApiFp(this.configuration)
      .tweetsRecentSearch(
        requestParameters.query,
        requestParameters.startTime,
        requestParameters.endTime,
        requestParameters.sinceId,
        requestParameters.untilId,
        requestParameters.maxResults,
        requestParameters.nextToken,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TweetsApi - axios parameter creator
 * @export
 */
export const TweetsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * @summary Add or delete rules from a user\'s active rule set.
     * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest
     * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOrDeleteRules: async (
      addOrDeleteRulesRequest: AddOrDeleteRulesRequest,
      dryRun?: boolean,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addOrDeleteRulesRequest' is not null or undefined
      if (
        addOrDeleteRulesRequest === null ||
        addOrDeleteRulesRequest === undefined
      ) {
        throw new RequiredError(
          'addOrDeleteRulesRequest',
          'Required parameter addOrDeleteRulesRequest was null or undefined when calling addOrDeleteRules.',
        )
      }
      const localVarPath = `/2/tweets/search/stream/rules`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (dryRun !== undefined) {
        localVarQueryParameter['dry_run'] = dryRun
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const nonString = typeof addOrDeleteRulesRequest !== 'string'
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type'],
            )
          : nonString
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
            addOrDeleteRulesRequest !== undefined
              ? addOrDeleteRulesRequest
              : {},
          )
        : addOrDeleteRulesRequest || ''

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Returns hydrated Tweet objects
     * @param {string} id A single Tweet ID.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTweetById: async (
      id: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling findTweetById.',
        )
      }
      const localVarPath = `/2/tweets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Returns hydrated Tweet objects
     * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTweetsById: async (
      ids: Array<string>,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          'ids',
          'Required parameter ids was null or undefined when calling findTweetsById.',
        )
      }
      const localVarPath = `/2/tweets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (ids) {
        localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv)
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * @summary Returns rules from a user\'s active rule set.
     * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRules: async (
      ids?: Array<string>,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/2/tweets/search/stream/rules`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (ids) {
        localVarQueryParameter['ids'] = ids
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Tweet ID in the path is that of the reply to hide or unhide.
     * @summary Hides or unhides a reply to an owned conversation.
     * @param {string} id The ID of the reply that you want to hide or unhide.
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hideReplyById: async (
      id: string,
      inlineObject?: InlineObject,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling hideReplyById.',
        )
      }
      const localVarPath = `/2/tweets/{id}/hidden`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const nonString = typeof inlineObject !== 'string'
      const needsSerialization =
        nonString && configuration && configuration.isJsonMime
          ? configuration.isJsonMime(
              localVarRequestOptions.headers['Content-Type'],
            )
          : nonString
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(inlineObject !== undefined ? inlineObject : {})
        : inlineObject || ''

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Streams a deterministic 1% of public tweets.
     * @summary Streams a deterministic 1% of public tweets.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sampleStream: async (
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/2/tweets/sample/stream`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Streams tweets matching a user\'s active rule set.
     * @summary Streams tweets matching a user\'s active rule set.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchStream: async (
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/2/tweets/search/stream`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns Tweets that match a search query.
     * @summary Returns Tweets that match a search query.
     * @param {string} query One query/rule/filter for matching Tweets. Up to 1024 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsFullarchiveSearch: async (
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      if (query === null || query === undefined) {
        throw new RequiredError(
          'query',
          'Required parameter query was null or undefined when calling tweetsFullarchiveSearch.',
        )
      }
      const localVarPath = `/2/tweets/search/all`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] =
          (startTime as any) instanceof Date
            ? (startTime as any).toISOString()
            : startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] =
          (endTime as any) instanceof Date
            ? (endTime as any).toISOString()
            : endTime
      }

      if (sinceId !== undefined) {
        localVarQueryParameter['since_id'] = sinceId
      }

      if (untilId !== undefined) {
        localVarQueryParameter['until_id'] = untilId
      }

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (nextToken !== undefined) {
        localVarQueryParameter['next_token'] = nextToken
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns Tweets from the last 7 days that match a search query.
     * @summary Returns Tweets from the last 7 days that match a search query.
     * @param {string} query One query/rule/filter for matching Tweets. Up to 512 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsRecentSearch: async (
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'query' is not null or undefined
      if (query === null || query === undefined) {
        throw new RequiredError(
          'query',
          'Required parameter query was null or undefined when calling tweetsRecentSearch.',
        )
      }
      const localVarPath = `/2/tweets/search/recent`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      if (startTime !== undefined) {
        localVarQueryParameter['start_time'] =
          (startTime as any) instanceof Date
            ? (startTime as any).toISOString()
            : startTime
      }

      if (endTime !== undefined) {
        localVarQueryParameter['end_time'] =
          (endTime as any) instanceof Date
            ? (endTime as any).toISOString()
            : endTime
      }

      if (sinceId !== undefined) {
        localVarQueryParameter['since_id'] = sinceId
      }

      if (untilId !== undefined) {
        localVarQueryParameter['until_id'] = untilId
      }

      if (maxResults !== undefined) {
        localVarQueryParameter['max_results'] = maxResults
      }

      if (nextToken !== undefined) {
        localVarQueryParameter['next_token'] = nextToken
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (mediaFields) {
        localVarQueryParameter['media.fields'] = mediaFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (placeFields) {
        localVarQueryParameter['place.fields'] = placeFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (pollFields) {
        localVarQueryParameter['poll.fields'] = pollFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TweetsApi - functional programming interface
 * @export
 */
export const TweetsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * @summary Add or delete rules from a user\'s active rule set.
     * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest
     * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addOrDeleteRules(
      addOrDeleteRulesRequest: AddOrDeleteRulesRequest,
      dryRun?: boolean,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AddOrDeleteRulesResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).addOrDeleteRules(addOrDeleteRulesRequest, dryRun, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Returns hydrated Tweet objects
     * @param {string} id A single Tweet ID.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findTweetById(
      id: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SingleTweetLookupResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).findTweetById(
        id,
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Returns hydrated Tweet objects
     * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findTweetsById(
      ids: Array<string>,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TweetLookupResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).findTweetsById(
        ids,
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * @summary Returns rules from a user\'s active rule set.
     * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRules(
      ids?: Array<string>,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2002>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).getRules(ids, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Tweet ID in the path is that of the reply to hide or unhide.
     * @summary Hides or unhides a reply to an owned conversation.
     * @param {string} id The ID of the reply that you want to hide or unhide.
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async hideReplyById(
      id: string,
      inlineObject?: InlineObject,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse200>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).hideReplyById(id, inlineObject, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Streams a deterministic 1% of public tweets.
     * @summary Streams a deterministic 1% of public tweets.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sampleStream(
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamingTweet>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).sampleStream(
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Streams tweets matching a user\'s active rule set.
     * @summary Streams tweets matching a user\'s active rule set.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchStream(
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<FilteredStreamingTweet>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).searchStream(
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns Tweets that match a search query.
     * @summary Returns Tweets that match a search query.
     * @param {string} query One query/rule/filter for matching Tweets. Up to 1024 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tweetsFullarchiveSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2001>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).tweetsFullarchiveSearch(
        query,
        startTime,
        endTime,
        sinceId,
        untilId,
        maxResults,
        nextToken,
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns Tweets from the last 7 days that match a search query.
     * @summary Returns Tweets from the last 7 days that match a search query.
     * @param {string} query One query/rule/filter for matching Tweets. Up to 512 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async tweetsRecentSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<TweetSearchResponse>
    > {
      const localVarAxiosArgs = await TweetsApiAxiosParamCreator(
        configuration,
      ).tweetsRecentSearch(
        query,
        startTime,
        endTime,
        sinceId,
        untilId,
        maxResults,
        nextToken,
        expansions,
        tweetFields,
        userFields,
        mediaFields,
        placeFields,
        pollFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * TweetsApi - factory interface
 * @export
 */
export const TweetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * @summary Add or delete rules from a user\'s active rule set.
     * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest
     * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addOrDeleteRules(
      addOrDeleteRulesRequest: AddOrDeleteRulesRequest,
      dryRun?: boolean,
      options?: any,
    ): AxiosPromise<AddOrDeleteRulesResponse> {
      return TweetsApiFp(configuration)
        .addOrDeleteRules(addOrDeleteRulesRequest, dryRun, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Returns hydrated Tweet objects
     * @param {string} id A single Tweet ID.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTweetById(
      id: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<SingleTweetLookupResponse> {
      return TweetsApiFp(configuration)
        .findTweetById(
          id,
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a variety of information about the Tweet specified by the requested ID
     * @summary Returns hydrated Tweet objects
     * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTweetsById(
      ids: Array<string>,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<TweetLookupResponse> {
      return TweetsApiFp(configuration)
        .findTweetsById(
          ids,
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * @summary Returns rules from a user\'s active rule set.
     * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRules(
      ids?: Array<string>,
      options?: any,
    ): AxiosPromise<InlineResponse2002> {
      return TweetsApiFp(configuration)
        .getRules(ids, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Tweet ID in the path is that of the reply to hide or unhide.
     * @summary Hides or unhides a reply to an owned conversation.
     * @param {string} id The ID of the reply that you want to hide or unhide.
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hideReplyById(
      id: string,
      inlineObject?: InlineObject,
      options?: any,
    ): AxiosPromise<InlineResponse200> {
      return TweetsApiFp(configuration)
        .hideReplyById(id, inlineObject, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Streams a deterministic 1% of public tweets.
     * @summary Streams a deterministic 1% of public tweets.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sampleStream(
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<StreamingTweet> {
      return TweetsApiFp(configuration)
        .sampleStream(
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Streams tweets matching a user\'s active rule set.
     * @summary Streams tweets matching a user\'s active rule set.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchStream(
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<FilteredStreamingTweet> {
      return TweetsApiFp(configuration)
        .searchStream(
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns Tweets that match a search query.
     * @summary Returns Tweets that match a search query.
     * @param {string} query One query/rule/filter for matching Tweets. Up to 1024 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsFullarchiveSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<InlineResponse2001> {
      return TweetsApiFp(configuration)
        .tweetsFullarchiveSearch(
          query,
          startTime,
          endTime,
          sinceId,
          untilId,
          maxResults,
          nextToken,
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns Tweets from the last 7 days that match a search query.
     * @summary Returns Tweets from the last 7 days that match a search query.
     * @param {string} query One query/rule/filter for matching Tweets. Up to 512 characters.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>} [placeFields] A comma separated list of Place fields to display.
     * @param {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    tweetsRecentSearch(
      query: string,
      startTime?: string,
      endTime?: string,
      sinceId?: string,
      untilId?: string,
      maxResults?: number,
      nextToken?: string,
      expansions?: Array<
        | 'author_id'
        | 'referenced_tweets.id'
        | 'in_reply_to_user_id'
        | 'geo.place_id'
        | 'attachments.media_keys'
        | 'attachments.poll_ids'
        | 'entities.mentions.username'
        | 'referenced_tweets.id.author_id'
      >,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      mediaFields?: Array<
        | 'media_key'
        | 'duration_ms'
        | 'height'
        | 'preview_image_url'
        | 'type'
        | 'url'
        | 'width'
        | 'public_metrics'
        | 'non_public_metrics'
        | 'organic_metrics'
        | 'promoted_metrics'
      >,
      placeFields?: Array<
        | 'id'
        | 'name'
        | 'country_code'
        | 'place_type'
        | 'full_name'
        | 'country'
        | 'contained_within'
        | 'geo'
      >,
      pollFields?: Array<
        'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
      >,
      options?: any,
    ): AxiosPromise<TweetSearchResponse> {
      return TweetsApiFp(configuration)
        .tweetsRecentSearch(
          query,
          startTime,
          endTime,
          sinceId,
          untilId,
          maxResults,
          nextToken,
          expansions,
          tweetFields,
          userFields,
          mediaFields,
          placeFields,
          pollFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for addOrDeleteRules operation in TweetsApi.
 * @export
 * @interface TweetsApiAddOrDeleteRulesRequest
 */
export interface TweetsApiAddOrDeleteRulesRequest {
  /**
   *
   * @type {AddOrDeleteRulesRequest}
   * @memberof TweetsApiAddOrDeleteRules
   */
  readonly addOrDeleteRulesRequest: AddOrDeleteRulesRequest

  /**
   * Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
   * @type {boolean}
   * @memberof TweetsApiAddOrDeleteRules
   */
  readonly dryRun?: boolean
}

/**
 * Request parameters for findTweetById operation in TweetsApi.
 * @export
 * @interface TweetsApiFindTweetByIdRequest
 */
export interface TweetsApiFindTweetByIdRequest {
  /**
   * A single Tweet ID.
   * @type {string}
   * @memberof TweetsApiFindTweetById
   */
  readonly id: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiFindTweetById
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiFindTweetById
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiFindTweetById
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>}
   * @memberof TweetsApiFindTweetById
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiFindTweetById
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiFindTweetById
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * Request parameters for findTweetsById operation in TweetsApi.
 * @export
 * @interface TweetsApiFindTweetsByIdRequest
 */
export interface TweetsApiFindTweetsByIdRequest {
  /**
   * A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
   * @type {Array<string>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly ids: Array<string>

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiFindTweetsById
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * Request parameters for getRules operation in TweetsApi.
 * @export
 * @interface TweetsApiGetRulesRequest
 */
export interface TweetsApiGetRulesRequest {
  /**
   * A comma-separated list of Rule IDs.
   * @type {Array<string>}
   * @memberof TweetsApiGetRules
   */
  readonly ids?: Array<string>
}

/**
 * Request parameters for hideReplyById operation in TweetsApi.
 * @export
 * @interface TweetsApiHideReplyByIdRequest
 */
export interface TweetsApiHideReplyByIdRequest {
  /**
   * The ID of the reply that you want to hide or unhide.
   * @type {string}
   * @memberof TweetsApiHideReplyById
   */
  readonly id: string

  /**
   *
   * @type {InlineObject}
   * @memberof TweetsApiHideReplyById
   */
  readonly inlineObject?: InlineObject
}

/**
 * Request parameters for sampleStream operation in TweetsApi.
 * @export
 * @interface TweetsApiSampleStreamRequest
 */
export interface TweetsApiSampleStreamRequest {
  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiSampleStream
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiSampleStream
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiSampleStream
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>}
   * @memberof TweetsApiSampleStream
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiSampleStream
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiSampleStream
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * Request parameters for searchStream operation in TweetsApi.
 * @export
 * @interface TweetsApiSearchStreamRequest
 */
export interface TweetsApiSearchStreamRequest {
  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiSearchStream
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiSearchStream
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiSearchStream
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>}
   * @memberof TweetsApiSearchStream
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiSearchStream
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiSearchStream
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * Request parameters for tweetsFullarchiveSearch operation in TweetsApi.
 * @export
 * @interface TweetsApiTweetsFullarchiveSearchRequest
 */
export interface TweetsApiTweetsFullarchiveSearchRequest {
  /**
   * One query/rule/filter for matching Tweets. Up to 1024 characters.
   * @type {string}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly query: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
   * @type {string}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly startTime?: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
   * @type {string}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly endTime?: string

  /**
   * Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
   * @type {string}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly sinceId?: string

  /**
   * Returns results with a Tweet ID less than (that is, older than) the specified ID.
   * @type {string}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly untilId?: string

  /**
   * The maximum number of search results to be returned by a request.
   * @type {number}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly maxResults?: number

  /**
   * This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
   * @type {string}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly nextToken?: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiTweetsFullarchiveSearch
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * Request parameters for tweetsRecentSearch operation in TweetsApi.
 * @export
 * @interface TweetsApiTweetsRecentSearchRequest
 */
export interface TweetsApiTweetsRecentSearchRequest {
  /**
   * One query/rule/filter for matching Tweets. Up to 512 characters.
   * @type {string}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly query: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
   * @type {string}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly startTime?: string

  /**
   * YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
   * @type {string}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly endTime?: string

  /**
   * Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
   * @type {string}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly sinceId?: string

  /**
   * Returns results with a Tweet ID less than (that is, older than) the specified ID.
   * @type {string}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly untilId?: string

  /**
   * The maximum number of search results to be returned by a request.
   * @type {number}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly maxResults?: number

  /**
   * This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
   * @type {string}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly nextToken?: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'author_id' | 'referenced_tweets.id' | 'in_reply_to_user_id' | 'geo.place_id' | 'attachments.media_keys' | 'attachments.poll_ids' | 'entities.mentions.username' | 'referenced_tweets.id.author_id'>}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly expansions?: Array<
    | 'author_id'
    | 'referenced_tweets.id'
    | 'in_reply_to_user_id'
    | 'geo.place_id'
    | 'attachments.media_keys'
    | 'attachments.poll_ids'
    | 'entities.mentions.username'
    | 'referenced_tweets.id.author_id'
  >

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >

  /**
   * A comma separated list of Media fields to display.
   * @type {Array<'media_key' | 'duration_ms' | 'height' | 'preview_image_url' | 'type' | 'url' | 'width' | 'public_metrics' | 'non_public_metrics' | 'organic_metrics' | 'promoted_metrics'>}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly mediaFields?: Array<
    | 'media_key'
    | 'duration_ms'
    | 'height'
    | 'preview_image_url'
    | 'type'
    | 'url'
    | 'width'
    | 'public_metrics'
    | 'non_public_metrics'
    | 'organic_metrics'
    | 'promoted_metrics'
  >

  /**
   * A comma separated list of Place fields to display.
   * @type {Array<'id' | 'name' | 'country_code' | 'place_type' | 'full_name' | 'country' | 'contained_within' | 'geo'>}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly placeFields?: Array<
    | 'id'
    | 'name'
    | 'country_code'
    | 'place_type'
    | 'full_name'
    | 'country'
    | 'contained_within'
    | 'geo'
  >

  /**
   * A comma separated list of Poll fields to display.
   * @type {Array<'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'>}
   * @memberof TweetsApiTweetsRecentSearch
   */
  readonly pollFields?: Array<
    'id' | 'options' | 'voting_status' | 'end_datetime' | 'duration_minutes'
  >
}

/**
 * TweetsApi - object-oriented interface
 * @export
 * @class TweetsApi
 * @extends {BaseAPI}
 */
export class TweetsApi extends BaseAPI {
  /**
   * Add or delete rules from a user\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
   * @summary Add or delete rules from a user\'s active rule set.
   * @param {TweetsApiAddOrDeleteRulesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public addOrDeleteRules(
    requestParameters: TweetsApiAddOrDeleteRulesRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .addOrDeleteRules(
        requestParameters.addOrDeleteRulesRequest,
        requestParameters.dryRun,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a variety of information about the Tweet specified by the requested ID
   * @summary Returns hydrated Tweet objects
   * @param {TweetsApiFindTweetByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public findTweetById(
    requestParameters: TweetsApiFindTweetByIdRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .findTweetById(
        requestParameters.id,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a variety of information about the Tweet specified by the requested ID
   * @summary Returns hydrated Tweet objects
   * @param {TweetsApiFindTweetsByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public findTweetsById(
    requestParameters: TweetsApiFindTweetsByIdRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .findTweetsById(
        requestParameters.ids,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns rules from a user\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
   * @summary Returns rules from a user\'s active rule set.
   * @param {TweetsApiGetRulesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public getRules(
    requestParameters: TweetsApiGetRulesRequest = {},
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .getRules(requestParameters.ids, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Tweet ID in the path is that of the reply to hide or unhide.
   * @summary Hides or unhides a reply to an owned conversation.
   * @param {TweetsApiHideReplyByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public hideReplyById(
    requestParameters: TweetsApiHideReplyByIdRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .hideReplyById(
        requestParameters.id,
        requestParameters.inlineObject,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Streams a deterministic 1% of public tweets.
   * @summary Streams a deterministic 1% of public tweets.
   * @param {TweetsApiSampleStreamRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public sampleStream(
    requestParameters: TweetsApiSampleStreamRequest = {},
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .sampleStream(
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Streams tweets matching a user\'s active rule set.
   * @summary Streams tweets matching a user\'s active rule set.
   * @param {TweetsApiSearchStreamRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public searchStream(
    requestParameters: TweetsApiSearchStreamRequest = {},
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .searchStream(
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns Tweets that match a search query.
   * @summary Returns Tweets that match a search query.
   * @param {TweetsApiTweetsFullarchiveSearchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public tweetsFullarchiveSearch(
    requestParameters: TweetsApiTweetsFullarchiveSearchRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .tweetsFullarchiveSearch(
        requestParameters.query,
        requestParameters.startTime,
        requestParameters.endTime,
        requestParameters.sinceId,
        requestParameters.untilId,
        requestParameters.maxResults,
        requestParameters.nextToken,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns Tweets from the last 7 days that match a search query.
   * @summary Returns Tweets from the last 7 days that match a search query.
   * @param {TweetsApiTweetsRecentSearchRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TweetsApi
   */
  public tweetsRecentSearch(
    requestParameters: TweetsApiTweetsRecentSearchRequest,
    options?: any,
  ) {
    return TweetsApiFp(this.configuration)
      .tweetsRecentSearch(
        requestParameters.query,
        requestParameters.startTime,
        requestParameters.endTime,
        requestParameters.sinceId,
        requestParameters.untilId,
        requestParameters.maxResults,
        requestParameters.nextToken,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        requestParameters.mediaFields,
        requestParameters.placeFields,
        requestParameters.pollFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * This endpoint returns information about a user. Specify user by ID.
     * @summary Return details for the specified users
     * @param {string} id Required. A User ID.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUserById: async (
      id: string,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling findUserById.',
        )
      }
      const localVarPath = `/2/users/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint returns information about a user. Specify user by username.
     * @summary Return details for the specified users
     * @param {string} username Required. A username.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUserByUsername: async (
      username: string,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling findUserByUsername.',
        )
      }
      const localVarPath = `/2/users/by/username/{username}`.replace(
        `{${'username'}}`,
        encodeURIComponent(String(username)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint returns information about users. Specify users by their ID.
     * @summary Return details for the specified users
     * @param {Array<string>} ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUsersById: async (
      ids: Array<string>,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          'ids',
          'Required parameter ids was null or undefined when calling findUsersById.',
        )
      }
      const localVarPath = `/2/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (ids) {
        localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv)
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint returns information about users. Specify users by their username.
     * @summary Return details for the specified users
     * @param {Array<string>} usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUsersByUsername: async (
      usernames: Array<string>,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'usernames' is not null or undefined
      if (usernames === null || usernames === undefined) {
        throw new RequiredError(
          'usernames',
          'Required parameter usernames was null or undefined when calling findUsersByUsername.',
        )
      }
      const localVarPath = `/2/users/by`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com')
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication BearerToken required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function'
            ? await configuration.accessToken()
            : await configuration.accessToken
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken
      }

      // authentication UserToken required

      if (usernames) {
        localVarQueryParameter['usernames'] = usernames.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (expansions) {
        localVarQueryParameter['expansions'] = expansions.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (tweetFields) {
        localVarQueryParameter['tweet.fields'] = tweetFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      if (userFields) {
        localVarQueryParameter['user.fields'] = userFields.join(
          COLLECTION_FORMATS.csv,
        )
      }

      const queryParameters = new URLSearchParams(localVarUrlObj.search)
      for (const key in localVarQueryParameter) {
        queryParameters.set(key, localVarQueryParameter[key])
      }
      for (const key in options.query) {
        queryParameters.set(key, options.query[key])
      }
      localVarUrlObj.search = new URLSearchParams(queryParameters).toString()
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url:
          localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint returns information about a user. Specify user by ID.
     * @summary Return details for the specified users
     * @param {string} id Required. A User ID.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findUserById(
      id: string,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SingleUserLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).findUserById(id, expansions, tweetFields, userFields, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * This endpoint returns information about a user. Specify user by username.
     * @summary Return details for the specified users
     * @param {string} username Required. A username.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findUserByUsername(
      username: string,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SingleUserLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).findUserByUsername(
        username,
        expansions,
        tweetFields,
        userFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * This endpoint returns information about users. Specify users by their ID.
     * @summary Return details for the specified users
     * @param {Array<string>} ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findUsersById(
      ids: Array<string>,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).findUsersById(ids, expansions, tweetFields, userFields, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * This endpoint returns information about users. Specify users by their username.
     * @summary Return details for the specified users
     * @param {Array<string>} usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findUsersByUsername(
      usernames: Array<string>,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserLookupResponse>
    > {
      const localVarAxiosArgs = await UsersApiAxiosParamCreator(
        configuration,
      ).findUsersByUsername(
        usernames,
        expansions,
        tweetFields,
        userFields,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * This endpoint returns information about a user. Specify user by ID.
     * @summary Return details for the specified users
     * @param {string} id Required. A User ID.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUserById(
      id: string,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): AxiosPromise<SingleUserLookupResponse> {
      return UsersApiFp(configuration)
        .findUserById(id, expansions, tweetFields, userFields, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint returns information about a user. Specify user by username.
     * @summary Return details for the specified users
     * @param {string} username Required. A username.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUserByUsername(
      username: string,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): AxiosPromise<SingleUserLookupResponse> {
      return UsersApiFp(configuration)
        .findUserByUsername(
          username,
          expansions,
          tweetFields,
          userFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint returns information about users. Specify users by their ID.
     * @summary Return details for the specified users
     * @param {Array<string>} ids Required. A list of User IDs, comma-separated. You can specify up to 100 IDs.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUsersById(
      ids: Array<string>,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): AxiosPromise<UserLookupResponse> {
      return UsersApiFp(configuration)
        .findUsersById(ids, expansions, tweetFields, userFields, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint returns information about users. Specify users by their username.
     * @summary Return details for the specified users
     * @param {Array<string>} usernames Required . A list of usernames, comma-separated. You can specify up to 100 usernames.
     * @param {Array<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findUsersByUsername(
      usernames: Array<string>,
      expansions?: Array<'pinned_tweet_id'>,
      tweetFields?: Array<
        | 'id'
        | 'created_at'
        | 'text'
        | 'author_id'
        | 'in_reply_to_user_id'
        | 'referenced_tweets'
        | 'attachments'
        | 'withheld'
        | 'geo'
        | 'entities'
        | 'public_metrics'
        | 'possibly_sensitive'
        | 'source'
        | 'lang'
        | 'context_annotations'
        | 'non_public_metrics'
        | 'promoted_metrics'
        | 'organic_metrics'
        | 'conversation_id'
        | 'reply_settings'
      >,
      userFields?: Array<
        | 'id'
        | 'created_at'
        | 'name'
        | 'username'
        | 'protected'
        | 'verified'
        | 'withheld'
        | 'profile_image_url'
        | 'location'
        | 'url'
        | 'description'
        | 'entities'
        | 'pinned_tweet_id'
        | 'public_metrics'
      >,
      options?: any,
    ): AxiosPromise<UserLookupResponse> {
      return UsersApiFp(configuration)
        .findUsersByUsername(
          usernames,
          expansions,
          tweetFields,
          userFields,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * Request parameters for findUserById operation in UsersApi.
 * @export
 * @interface UsersApiFindUserByIdRequest
 */
export interface UsersApiFindUserByIdRequest {
  /**
   * Required. A User ID.
   * @type {string}
   * @memberof UsersApiFindUserById
   */
  readonly id: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'pinned_tweet_id'>}
   * @memberof UsersApiFindUserById
   */
  readonly expansions?: Array<'pinned_tweet_id'>

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof UsersApiFindUserById
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof UsersApiFindUserById
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >
}

/**
 * Request parameters for findUserByUsername operation in UsersApi.
 * @export
 * @interface UsersApiFindUserByUsernameRequest
 */
export interface UsersApiFindUserByUsernameRequest {
  /**
   * Required. A username.
   * @type {string}
   * @memberof UsersApiFindUserByUsername
   */
  readonly username: string

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'pinned_tweet_id'>}
   * @memberof UsersApiFindUserByUsername
   */
  readonly expansions?: Array<'pinned_tweet_id'>

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof UsersApiFindUserByUsername
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof UsersApiFindUserByUsername
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >
}

/**
 * Request parameters for findUsersById operation in UsersApi.
 * @export
 * @interface UsersApiFindUsersByIdRequest
 */
export interface UsersApiFindUsersByIdRequest {
  /**
   * Required. A list of User IDs, comma-separated. You can specify up to 100 IDs.
   * @type {Array<string>}
   * @memberof UsersApiFindUsersById
   */
  readonly ids: Array<string>

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'pinned_tweet_id'>}
   * @memberof UsersApiFindUsersById
   */
  readonly expansions?: Array<'pinned_tweet_id'>

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof UsersApiFindUsersById
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof UsersApiFindUsersById
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >
}

/**
 * Request parameters for findUsersByUsername operation in UsersApi.
 * @export
 * @interface UsersApiFindUsersByUsernameRequest
 */
export interface UsersApiFindUsersByUsernameRequest {
  /**
   * Required . A list of usernames, comma-separated. You can specify up to 100 usernames.
   * @type {Array<string>}
   * @memberof UsersApiFindUsersByUsername
   */
  readonly usernames: Array<string>

  /**
   * A comma separated list of fields to expand.
   * @type {Array<'pinned_tweet_id'>}
   * @memberof UsersApiFindUsersByUsername
   */
  readonly expansions?: Array<'pinned_tweet_id'>

  /**
   * A comma separated list of Tweet fields to display.
   * @type {Array<'id' | 'created_at' | 'text' | 'author_id' | 'in_reply_to_user_id' | 'referenced_tweets' | 'attachments' | 'withheld' | 'geo' | 'entities' | 'public_metrics' | 'possibly_sensitive' | 'source' | 'lang' | 'context_annotations' | 'non_public_metrics' | 'promoted_metrics' | 'organic_metrics' | 'conversation_id' | 'reply_settings'>}
   * @memberof UsersApiFindUsersByUsername
   */
  readonly tweetFields?: Array<
    | 'id'
    | 'created_at'
    | 'text'
    | 'author_id'
    | 'in_reply_to_user_id'
    | 'referenced_tweets'
    | 'attachments'
    | 'withheld'
    | 'geo'
    | 'entities'
    | 'public_metrics'
    | 'possibly_sensitive'
    | 'source'
    | 'lang'
    | 'context_annotations'
    | 'non_public_metrics'
    | 'promoted_metrics'
    | 'organic_metrics'
    | 'conversation_id'
    | 'reply_settings'
  >

  /**
   * A comma separated list of User fields to display.
   * @type {Array<'id' | 'created_at' | 'name' | 'username' | 'protected' | 'verified' | 'withheld' | 'profile_image_url' | 'location' | 'url' | 'description' | 'entities' | 'pinned_tweet_id' | 'public_metrics'>}
   * @memberof UsersApiFindUsersByUsername
   */
  readonly userFields?: Array<
    | 'id'
    | 'created_at'
    | 'name'
    | 'username'
    | 'protected'
    | 'verified'
    | 'withheld'
    | 'profile_image_url'
    | 'location'
    | 'url'
    | 'description'
    | 'entities'
    | 'pinned_tweet_id'
    | 'public_metrics'
  >
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * This endpoint returns information about a user. Specify user by ID.
   * @summary Return details for the specified users
   * @param {UsersApiFindUserByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public findUserById(
    requestParameters: UsersApiFindUserByIdRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .findUserById(
        requestParameters.id,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint returns information about a user. Specify user by username.
   * @summary Return details for the specified users
   * @param {UsersApiFindUserByUsernameRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public findUserByUsername(
    requestParameters: UsersApiFindUserByUsernameRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .findUserByUsername(
        requestParameters.username,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint returns information about users. Specify users by their ID.
   * @summary Return details for the specified users
   * @param {UsersApiFindUsersByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public findUsersById(
    requestParameters: UsersApiFindUsersByIdRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .findUsersById(
        requestParameters.ids,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint returns information about users. Specify users by their username.
   * @summary Return details for the specified users
   * @param {UsersApiFindUsersByUsernameRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public findUsersByUsername(
    requestParameters: UsersApiFindUsersByUsernameRequest,
    options?: any,
  ) {
    return UsersApiFp(this.configuration)
      .findUsersByUsername(
        requestParameters.usernames,
        requestParameters.expansions,
        requestParameters.tweetFields,
        requestParameters.userFields,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}
